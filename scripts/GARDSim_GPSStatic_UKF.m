%% GPS Position Solution using UKF
% Written by Duncan Greer 2 Feb 2007
%
% $Id: GARDSim_GPSStatic_UKF.m 1879 2008-07-15 05:20:21Z n2523710 $
%
%
%
%
%
% x1  = ECEF X
% x2  = ECEF Y
% x3  = ECEF Z
% x4  = ECEF X Velocity
% x5  = ECEF Y Velocity
% x6  = ECEF Z Velocity
% x7  = Receiver Clock Bias (Rb)
% x8  = Receiver Clock Drift Rate (Rf)
%

%% setup simulation

% set number formatting for display
format long g;

% load GPS constants
GPSConstants;

%% Load data - Note, this mat file is generated by the commented code
%% below.
%load 'data/Ground_Test_Data/2Feb2007/flexpak.mat';
%load 'data/Ground_Test_Data/22Feb2007/flexpak.mat';
load 'data/Ground_Test_Data/26_27Feb2007/flexpak.mat';
meanECEF =  [-5046773.35774802  2568446.08440315 -2925289.01760974];

% % a hack for this file = approx pos is wrong
% ApproxPos = [-5046719.69001578,2568403.35951166,-2925318.76002602];
% meanECEF =  [-5046773.35774802  2568446.08440315 -2925289.01760974];
% 
% ALPHA = [9.3132E-09  0.0000E+00 -5.9605E-08  0.0000E+00];
% BETA = [9.0112D+04  0.0000E+00 -1.9661E+05  0.0000E+00];

% load observation and nav data
% [GPSTime_Week, GPSTime_Sec,NumberRinexObsTypes,ValidDataRinexObs,ApproxPos, Novatel_C1, Novatel_L1, Novatel_D1, Novatel_S1, Novatel_P2, Novatel_L2, Novatel_D2, Novatel_S2] = ReadRinexNovatel('data/Ground_Test_Data/2Feb2007/02020330.07O');
% [SV_Ephemeris, ALPHA, BETA] = freadnav('data/Ground_Test_Data/2Feb2007/02020330.07N');
% 
NumberEpochsGPS = size(Novatel_C1,2);
gps_dt = 1;

NumberSVs = size(Novatel_C1,1);
SVDontUse = zeros(1,NumberSVs);
% 
% % propogate satellite orbits and velocities
% disp('Calculating Satellite Orbits...');
% 
% % preallocate storage vectors for speed
% SV_X_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Y_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Z_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_T_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Xvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Yvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Zvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Tvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Xacc_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Yacc_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Zacc_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Tacc_Data = zeros(NumberEpochsGPS,NumberSVs);
% 
% for i=1:NumberEpochsGPS
%     for j=1:NumberSVs
%         [SV_X_Data(i,j), SV_Y_Data(i,j), SV_Z_Data(i,j), SV_T_Data(i,j), ValidPosData(i,j)] = ...
%                GPSOrbitPropagator(GPSTime_Week(i), GPSTime_Sec(i), j, SV_Ephemeris, 7500);
%         [SV_Xvel_Data(i,j), SV_Yvel_Data(i,j), SV_Zvel_Data(i,j), SV_Tvel_Data(i,j), ...
%          SV_Xacc_Data(i,j), SV_Yacc_Data(i,j), SV_Zacc_Data(i,j), SV_Tacc_Data(i,j), ValidVelData(i,j)] = ...
%          GPSOrbitPropagatorVelocities(GPSTime_Week(i),GPSTime_Sec(i), j, SV_Ephemeris);
%     end
%     
%     if(mod(i,1000) == 0)
%         disp(sprintf('Completed Epoch %d',i));
%     end
% end



%% arrange pseudorange measurements

PR_Sim = Novatel_C1';
PRR_Sim = -Novatel_D1' * L1_Wavelength;
CP_Sim = Novatel_L1';

% position
[InitialPosition(1),InitialPosition(2),InitialPosition(3)] = ECEF2LLH(ApproxPos);
% velocity
InitialVelocity = [0 0 0]';  % NED velocities in m/s

% get the initial meridian and prime radii of curvature
RM = MeridianRadius(InitialPosition(2));
RP = PrimeRadius(InitialPosition(2));
Tecef2ned = T_ECEF2NED(InitialPosition(2),InitialPosition(1));

% 3 position, 3 velocity and 2 clock
NumberStates = 8;

% process noise states - 8
ProcessNoiseStates = 8;  

% use a maximum of 6 measurements (PR+PRR)
MeasurementNoiseStates=12;


Na = NumberStates+ProcessNoiseStates+MeasurementNoiseStates;

% UKF scaling parameters
alpha = 0.1; % range: 1e-3 < alpha <= 1
beta = 2;  % 2 is optimal for gaussian priors
kapa = 0;  %

LAMBDA = alpha^2 * (Na+kapa) - Na;



TimeGPS = [0:gps_dt:NumberEpochsGPS-1];


%% initialise covariances
Px_kminus = eye(NumberStates,NumberStates);
Px_kminus(1:3,1:3) = eye(3,3)*100^2;
Px_kminus(4:6,4:6) = eye(3,3)*10^2;
Px_kminus(7,7) = 100^2;
Px_kminus(8,8) = 10^2;




%GPS_PR_UERE = 7.5;
GPS_PR_UERE = 4.95;  % URA=0;IONO=4m;Tropo=0.7m;Multipath=1.4m;Receiver Noise=0.5m
GPS_PRR_UERE = 0.2;

R = eye(MeasurementNoiseStates,MeasurementNoiseStates);
R(1:6,1:6) = eye(6,6)*GPS_PR_UERE^2;
R(7:12,7:12) = eye(6,6)*GPS_PRR_UERE^2;



x_hat_kminus = zeros(NumberStates,1);
%x_hat_kminus(1:3,1) = ApproxPos;
%x_hat_kminus(7,1) = 12;
GRASOn = 0;


x_hat_kminus(1:3,1) = [ -5046780.28152946          2568450.53282855         -2925294.35054563 ]';
x_hat_kminus(7,1) = 12.9024664188715;

SV_Azimuth = zeros(NumberEpochsGPS,NumberSVs);
SV_Elevation =  zeros(NumberEpochsGPS,NumberSVs);


SVDontUse(25) = 1;
SVDontUse(16) = 1;
SVDontUse(20) = 1;

URALimit = 3;

%% loop through and check for SV unhealthy (Ephemeris param 27)
for i=1:size(SV_Ephemeris,1)
   
   % check for unhealthy flag 
   if(SV_Ephemeris(i,27) ~= 0)
       disp(sprintf('SV %d Ephemeris Unhealthy',SV_Ephemeris(i,1)));
      SVDontUse(SV_Ephemeris(i,1)) = 1;
   end
   
   % check for large URA
   
   if(SV_Ephemeris(i,26) > URALimit)
       disp(sprintf('SV %d URA Exceeds Limit (%d)',SV_Ephemeris(i,1),URALimit));
      SVDontUse(SV_Ephemeris(i,1)) = 1;
   end
   
end



%% values for RAIM FDE

% PFalseAlarm = 2.22e-8;
% a =  [31.2919346425215; ...
%           35.2463471007126; ...
%           38.4953686364599; ...
%           41.4010185618922; ...
%            44.090770631714; ...
%           46.6276102566246; ...
%           49.0483514687134; ...
%           51.3768201044926; ...
%           53.6295337202138; ...
%           55.8185260702011; ...
%           57.9529000257331; ...
%           60.0397472340809; ...
%           62.0847253044164; ...
%            64.092436838505; ...
%            66.066688033301; ...
%            68.010670670063; ...
%           69.9270936151405; ...
%           71.8182800246577; ...
%           73.6862406187531; ...
%           75.5327299572836];
% 
% lambdatrue = [75.4140000000001; ...
%           80.2599999999999; ...
%           83.9499999999999; ...
%           87.0779999999999; ...
%           89.8469999999999; ...
%           92.3639999999999; ...
%           94.6879999999999; ...
%           96.8589999999999; ...
%                     98.906; ...
%                    100.848; ...
%                    102.698; ...
%                    104.468; ...
%                     106.17; ...
%                     107.81; ...
%                    109.396; ...
%                     110.93; ...
%                     112.42; ...
%                    113.865; ...
%                    115.275; ...
%                    116.647];
PFalseAlarm = 2e-5;
PMissedDetection = 0.047;

a =   [         18.189293484087;...
          21.6395565688235;...
          24.4623581112611;...
          26.9869539367368;...
          29.3272057089061;...
          31.5385558129051];

lambdatrue = [35.3000000000002;...
          38.9000000000003;...
          41.6000000000003;...
          43.8000000000004;...
          45.7000000000004;...
          47.5000000000004];
               
               
               
               
               
%% parameters for EKF

% power spectral densitites of the process noise - 
% Sp - position error
% Sf - clock bias error
% Sg - clock drift error

Sp = 10^2;  %% Static receiver
Sf = 2*2e-16*Speedoflight^2;
Sg = 8*pi^2*2e-17*Speedoflight^2;
% Sf = 10;
% Sg = 1;

% setup state transition - time invariant if dt is constant
EKF_phi = eye(NumberStates,NumberStates);
EKF_phi(1,5) = gps_dt;
EKF_phi(2,6) = gps_dt;
EKF_phi(3,7) = gps_dt;
EKF_phi(4,8) = gps_dt;


% setup Q and R matrices (process and noise covariance)
EKF_Q = zeros(NumberStates,NumberStates);

Sp_dt3 = Sp * (gps_dt ^ 3) / 3;
Sp_dt2 = Sp * (gps_dt ^ 2) / 2;
Sp_dt = Sp * gps_dt;
Sf_dt = Sf * gps_dt;
Sg_dt3 = Sg * (gps_dt ^ 3) / 3;
Sg_dt2 = Sg * (gps_dt ^ 2) / 2;
Sg_dt = Sg * gps_dt;

EKF_Q(1,1) = Sp_dt3;
EKF_Q(2,2) = Sp_dt3;
EKF_Q(3,3) = Sp_dt3;

EKF_Q(1,5) = Sp_dt2;
EKF_Q(2,6) = Sp_dt2;
EKF_Q(3,7) = Sp_dt2;
EKF_Q(4,8) = Sg_dt2;
EKF_Q(5,1) = Sp_dt2;
EKF_Q(6,2) = Sp_dt2;
EKF_Q(7,3) = Sp_dt2;
EKF_Q(8,4) = Sg_dt2;

EKF_Q(4,4) = Sf_dt + Sg_dt3;
EKF_Q(5,5) = Sp_dt;
EKF_Q(6,6) = Sp_dt;
EKF_Q(7,7) = Sp_dt;
EKF_Q(8,8) = Sg_dt;


EKF_R = R;

EKF_R_Sub = eye(MeasurementNoiseStates-2,MeasurementNoiseStates-2);
EKF_R_Sub(1:5,1:5) = eye(5,5)*GPS_PR_UERE^2;
EKF_R_Sub(6:10,6:10) = eye(5,5)*GPS_PRR_UERE^2;

EKF_x_hat_kplus = x_hat_kminus;
EKF_Px_kplus = eye(NumberStates,NumberStates);
EKF_Px_kplus(1:3,1:3) = eye(3,3)*100^2;
EKF_Px_kplus(5:7,5:7) = eye(3,3)*10^2;
EKF_Px_kplus(4,4) = 100^2;
EKF_Px_kplus(8,8) = 10^2;
               



UKF_Q = zeros(ProcessNoiseStates,ProcessNoiseStates);
UKF_Q(1,1) = Sp_dt3;
UKF_Q(2,2) = Sp_dt3;
UKF_Q(3,3) = Sp_dt3;
UKF_Q(4,4) = Sp_dt;
UKF_Q(5,5) = Sp_dt;
UKF_Q(6,6) = Sp_dt;

UKF_Q(1,4) = Sp_dt2;
UKF_Q(2,5) = Sp_dt2;
UKF_Q(3,6) = Sp_dt2;

UKF_Q(4,1) = Sp_dt2;
UKF_Q(5,2) = Sp_dt2;
UKF_Q(6,3) = Sp_dt2;

UKF_Q(8,7) = Sg_dt2;
UKF_Q(7,8) = Sg_dt2;

UKF_Q(7,7) = Sf_dt + Sg_dt3;
UKF_Q(8,8) = Sg_dt;


StartTime = 1;
EndTime = 86401;



%% start gps solutions
for Epoch_lo = StartTime:EndTime

    % get the gps time - used for the iono correction
    %GPSTime  = 259199 + Epoch_lo;
    GPSTime = GPSTime_Sec(Epoch_lo);
    
    

    % perform state prediction
    % generate augmented state vector
    xa_hat_kminus = [x_hat_kminus;zeros(ProcessNoiseStates,1);zeros(MeasurementNoiseStates,1)];

    Pxa_kminus = [Px_kminus          zeros(NumberStates,NumberStates) zeros(NumberStates,MeasurementNoiseStates);
              zeros(ProcessNoiseStates,NumberStates) UKF_Q           zeros(ProcessNoiseStates,MeasurementNoiseStates);
              zeros(MeasurementNoiseStates,NumberStates) zeros(MeasurementNoiseStates,ProcessNoiseStates)  R];
          
          
          
          
          
    blah = sqrt(Na+LAMBDA) * chol(Pxa_kminus);
    for i=0:Na
        if i==0
            xs_0 = xa_hat_kminus;
            W_0_m = LAMBDA / (Na + LAMBDA);
            W_0_c = W_0_m + (1 - alpha^2 + beta);
        else
            xs_i(:,i) = xa_hat_kminus + blah(i,:)';
            xs_i(:,i+Na) = xa_hat_kminus - blah(i,:)';
            W_i_m = 1 / (2 * (Na + LAMBDA));
            W_i_c = W_i_m;
        end
    end

    
    
    
    
    % propagate system dynamics
    for i=0:2*Na
        if i==0
            %% zeroth point
            
            % position
            xs_0_k(1) = xs_0(1) + xs_0(4)*gps_dt;
            xs_0_k(2) = xs_0(2) + xs_0(5)*gps_dt;
            xs_0_k(3) = xs_0(3) + xs_0(6)*gps_dt;
            xs_0_k(7) = xs_0(7) + xs_0(8)*gps_dt;

            
            % velocity
            xs_0_k(4) = xs_0(4);
            xs_0_k(5) = xs_0(5);
            xs_0_k(6) = xs_0(6);
            xs_0_k(8) = xs_0(8);
%             xs_0_k(4) = xs_0(4) + xs_0(9)*gps_dt;
%             xs_0_k(5) = xs_0(5) + xs_0(10)*gps_dt;
%             xs_0_k(6) = xs_0(6) + xs_0(11)*gps_dt;
%             xs_0_k(8) = xs_0(8);
%             
%             % acceleration
%             xs_0_k(9) = xs_0(9);
%             xs_0_k(10) = xs_0(10);
%             xs_0_k(11) = xs_0(11);
%             
            
            
            %% add process noise
            V = xs_0(NumberStates+1:NumberStates+ProcessNoiseStates)';
            xs_0_k(1:NumberStates) = xs_0_k(1:NumberStates) + V;
            
            
        else
            
            % i-points
            
            % position
            xs_i_k(1,i) = xs_i(1,i) + xs_i(4,i)*gps_dt;
            xs_i_k(2,i) = xs_i(2,i) + xs_i(5,i)*gps_dt;
            xs_i_k(3,i) = xs_i(3,i) + xs_i(6,i)*gps_dt;
            xs_i_k(7,i) = xs_i(7,i) + xs_i(8,i)*gps_dt;

            
            % velocity
%             xs_i_k(4,i) = xs_i(4,i) + xs_i(9,i)*gps_dt;
%             xs_i_k(5,i) = xs_i(5,i) + xs_i(10,i)*gps_dt;
%             xs_i_k(6,i) = xs_i(6,i) + xs_i(11,i)*gps_dt;
%             xs_i_k(8,i) = xs_i(8,i);
            xs_i_k(4,i) = xs_i(4,i);
            xs_i_k(5,i) = xs_i(5,i);
            xs_i_k(6,i) = xs_i(6,i);
            xs_i_k(8,i) = xs_i(8,i);
            % acceleration
%             xs_i_k(9,i) = xs_i(9,i);
%             xs_i_k(10,i) = xs_i(10,i);
%             xs_i_k(11,i) = xs_i(11,i);
            
            
            
            %% add process noise
            V = xs_i(NumberStates+1:NumberStates+ProcessNoiseStates,i);
            xs_i_k(1:NumberStates,i) = xs_i_k(1:NumberStates,i) + V;
        end
    end
    
    
    
    
    
    
    
    
    W = eye(1,2*Na+1);
    W(1,1) = W_0_m;
    W(1,2:2*Na+1) = W_i_m;
    X = zeros(NumberStates,2*Na+1);
    X(:,1) = xs_0_k(1:NumberStates);
    X(:,2:2*Na+1) = xs_i_k(1:NumberStates,:);
    x_hat_kminus = (W*X')';

    nx = length(x_hat_kminus); nw = length(W);
    Px_kminus=((ones(nx,1)*W).*(X-x_hat_kminus*ones(1,nw)))*(X-x_hat_kminus*ones(1,nw))';
        
    % initial guess at user pos required to estimate earth rotation
    % correction
    UserPos(1:3) = [x_hat_kminus(1);x_hat_kminus(2);x_hat_kminus(3)];
 %   UserPos(4) = xs_0_k(7);
        
    % format the input measurement vectors
    SVIndex = 0;
    for SV=1:NumberSVs
        if((PR_Sim(Epoch_lo,SV) > 100) && SVDontUse(SV) == 0)  %%SV ~= ExcludeSVPRN
            % add to PR vector
            SVIndex = SVIndex + 1;

            SV_Vec(SVIndex) = SV;
            PR_Vec(SVIndex) = PR_Sim(Epoch_lo,SV);
            PRR_Vec(SVIndex) = PRR_Sim(Epoch_lo,SV);
            if(Epoch_lo == 1)
                PRR_Vec(SVIndex) = 0;
                %PR_csc(SVIndex) = PR_Vec(SVIndex);
            else
                if(CP_Sim(Epoch_lo-1,SV) == 0)
                    %PRR_Vec(SVIndex) = (CP_Sim(Epoch_lo+1,SV) - CP_Sim(Epoch_lo,SV));
                    %PR_csc(SVIndex) = PR_Vec(SVIndex);
                else
                    %PRR_Vec(SVIndex) = (CP_Sim(Epoch_lo,SV) - CP_Sim(Epoch_lo-1,SV));

                 %%% PERFORM CARRIER PHASE SMOOTHING of PR
                 %%% HERE


                   % alpha = gps_dt/100;
                    %P_proj = PR_prev + (L1_Wavelength/(2*pi))*(CP_Sim(Epoch_lo) - CP_Sim(Epoch_lo-1));
                    %PR_csc(SVIndex) = alpha * PR_Vec(SVIndex) + (1-alpha)*P_proj;                            

                end
            end
            % save previous value
            %PR_prev = PR_csc(SVIndex);

            % dont use the carrier smoothed code
            %PR_Vec = PR_csc;                  



%             SVPos(SVIndex,:) = [SV_X_Data(Epoch_lo,SV) SV_Y_Data(Epoch_lo,SV) SV_Z_Data(Epoch_lo,SV) SV_T_Data(Epoch_lo,SV)*c];
%             SVVel(SVIndex,:) = [SV_Xvel_Data(Epoch_lo,SV) SV_Yvel_Data(Epoch_lo,SV) SV_Zvel_Data(Epoch_lo,SV) SV_Tvel_Data(Epoch_lo,SV)*c];
%             SVAcc(SVIndex,:) = [SV_Xacc_Data(Epoch_lo,SV) SV_Yacc_Data(Epoch_lo,SV) SV_Zacc_Data(Epoch_lo,SV) SV_Tacc_Data(Epoch_lo,SV)*c];

            [SVPos(SVIndex,1), SVPos(SVIndex,2), SVPos(SVIndex,3), SVPos(SVIndex,4), ValidPosData(Epoch_lo,SV)] = ...
               GPSOrbitPropagator(GPSTime_Week(Epoch_lo), GPSTime_Sec(Epoch_lo) - PR_Vec(SVIndex)/Speedoflight, SV, SV_Ephemeris, 7500);
           
             [SVVel(SVIndex,1), SVVel(SVIndex,2), SVVel(SVIndex,3), SVVel(SVIndex,4), ...
              SVAcc(SVIndex,1), SVAcc(SVIndex,2), SVAcc(SVIndex,3), SVAcc(SVIndex,4), ValidVelData(Epoch_lo,SV)] = ...
              GPSOrbitPropagatorVelocities(GPSTime_Week(Epoch_lo),GPSTime_Sec(Epoch_lo)-PR_Vec(SVIndex)/Speedoflight, SV, SV_Ephemeris);
          
            SVPos(SVIndex,4) = SVPos(SVIndex,4) * Speedoflight;
            SVVel(SVIndex,4) = SVVel(SVIndex,4) * Speedoflight;
            SVAcc(SVIndex,4) = SVAcc(SVIndex,4) * Speedoflight;

            [SV_Azimuth(Epoch_lo,SV), SV_Elevation(Epoch_lo,SV)] = AzEl(UserPos(1:3), SVPos(SVIndex,1:3));
           
            % calculate the iono delay correction - single frequency user
            % model from ICD 200
            if(GRASOn == 0)
                ionodelay = ionomodel(GPSTime, UserPos(1:3), SVPos(SVIndex,1:3), ALPHA, BETA);
                PR_Vec(SVIndex) = PR_Vec(SVIndex) - ionodelay;
            end

            % calculate hte earth rotation correction as per Kayton pg 228
            % eq 5.67

            
            PR_Vec_raw(SVIndex) = PR_Vec(SVIndex);  % save a raw (uncorrected copy) of the PR vector for use in the LSQ algorithm later.
            delta_pr_omegaedot = -(OMEGAedot / Speedoflight) * (SVPos(SVIndex,1) *UserPos(2) - SVPos(SVIndex,2) * UserPos(1));
            PR_Vec(SVIndex) = PR_Vec(SVIndex) + delta_pr_omegaedot + SVPos(SVIndex,4);
            PRR_Vec(SVIndex) = PRR_Vec(SVIndex) + SVVel(SVIndex,4);


        end
    end

    NumberGPSMeasurements = length(PR_Vec);



    if NumberGPSMeasurements > 6
        NumberGPSMeasurements = 6;
    end

    % calculate the number of sub-filters required for single satellite failture detection
    NumberSubMeasurements = NumberGPSMeasurements-1;
    NumberSubFilters = nchoosek(NumberGPSMeasurements,NumberSubMeasurements);
        
    % formulate the measurment vector
    y_k = [PR_Vec(1:NumberGPSMeasurements)';PRR_Vec(1:NumberGPSMeasurements)'];
    

    for k = 1:NumberGPSMeasurements
        % find apriori estimate of pseudorange for each sigma point

        % zero-th sigma point

        
        % Get User position in ECEF
        UserPos(1:3) = [xs_0_k(1);xs_0_k(2);xs_0_k(3)];
        UserPos(4) = xs_0_k(7);
        UserVel(1:3) =  [xs_0_k(4);xs_0_k(5);xs_0_k(6)];
        UserVel(4) = xs_0_k(8);
        
        geo_range_to_sat = sqrt((SVPos(k,1) - UserPos(1))^2 + (SVPos(k,2) - UserPos(2))^2 + (SVPos(k,3) - UserPos(3))^2);
        geo_vel_to_sat = (SVVel(k,1) - UserVel(1))*(SVPos(k,1)-UserPos(1)) + (SVVel(k,2) - UserVel(2))*(SVPos(k,2)-UserPos(2)) + (SVVel(k,3) - UserVel(3))*(SVPos(k,3)-UserPos(3));

    %% calculate measurement predicition
        % pseudorange prediction
        PR_Vec_minus_0(k) = geo_range_to_sat + UserPos(4) + xs_0(NumberStates+ProcessNoiseStates+k);% + UserVel(4) * gps_dt;  % geometric range + c * delta_T
        %predicted relative velocity of sv and receiver
        Relative_Velocity(k) = geo_vel_to_sat/geo_range_to_sat;
        PRR_Vec_minus_0(k) = Relative_Velocity(k) + UserVel(4) + xs_0(NumberStates+ProcessNoiseStates+MeasurementNoiseStates/2+k);

        for i=1:2*Na
            % Get User position in ECEF
            UserPos(1:3) = [xs_i_k(1,i);xs_i_k(2,i);xs_i_k(3,i)];
            UserPos(4) = xs_i_k(7,i);
            UserVel(1:3) =  [xs_i_k(4,i);xs_i_k(5,i);xs_i_k(6,i)];
            UserVel(4) = xs_i_k(8,i);
            
            
            geo_range_to_sat = sqrt((SVPos(k,1) - UserPos(1))^2 + (SVPos(k,2) - UserPos(2))^2 + (SVPos(k,3) - UserPos(3))^2);
            geo_vel_to_sat = (SVVel(k,1) - UserVel(1))*(SVPos(k,1)-UserPos(1)) + (SVVel(k,2) - UserVel(2))*(SVPos(k,2)-UserPos(2)) + (SVVel(k,3) - UserVel(3))*(SVPos(k,3)-UserPos(3));

            PR_Vec_minus_i(k,i) = geo_range_to_sat + UserPos(4) + xs_i(NumberStates+ProcessNoiseStates+k,i);% + UserVel(4) * gps_dt + xs_i(NumberStates+ProcessNoiseStates+k-1,i);  % geometric range + c * delta_T

            %predicted relative velocity of sv and receiver
            Relative_Velocity(k) = geo_vel_to_sat/geo_range_to_sat;
            PRR_Vec_minus_i(k,i) = Relative_Velocity(k) + UserVel(4) + xs_i(NumberStates+ProcessNoiseStates+MeasurementNoiseStates/2+k,i);
        end % for i=1:2*Na

        % calculate EKF H-matrix
        UserPos(1:4) = EKF_x_hat_kplus(1:4);
        UserVel(1:4) = EKF_x_hat_kplus(5:8);
        for m = 1:3
             ele(m) =  SVPos(k,m) - UserPos(m);
        end    

        r_VecCalc(k) =  norm(ele);   

        EKF_H(k,1) =  -ele(1)/r_VecCalc(k);
        EKF_H(k,2) =  -ele(2)/r_VecCalc(k);
        EKF_H(k,3) =  -ele(3)/r_VecCalc(k);
        EKF_H(k,4) = 1;   
        EKF_H(k,5) = 0;
        EKF_H(k,6) = 0;
        EKF_H(k,7) = 0;
        EKF_H(k,8) = 0;

        EKF_H(k+NumberGPSMeasurements,1) = 0;
        EKF_H(k+NumberGPSMeasurements,2) = 0;
        EKF_H(k+NumberGPSMeasurements,3) = 0;
        EKF_H(k+NumberGPSMeasurements,4) = 0;   
        EKF_H(k+NumberGPSMeasurements,5) = -ele(1)/r_VecCalc(k);
        EKF_H(k+NumberGPSMeasurements,6) = -ele(2)/r_VecCalc(k);
        EKF_H(k+NumberGPSMeasurements,7) = -ele(3)/r_VecCalc(k);
        EKF_H(k+NumberGPSMeasurements,8) = 1;

        % find apriori estimate of pseudorange
        PR_Vec_minus(k) = r_VecCalc(k) + UserPos(4) + UserVel(4) * gps_dt;  % geometric range + c * delta_T
        %predicted relative velocity of sv and receiver
        r_VecCalcVel(k) = (SVVel(k,1) - UserVel(1))*(SVPos(k,1)-UserPos(1)) + (SVVel(k,2) - UserVel(2))*(SVPos(k,2)-UserPos(2)) + (SVVel(k,3) - UserVel(3))*(SVPos(k,3)-UserPos(3));
        Relative_Velocity(k) = r_VecCalcVel(k)/r_VecCalc(k);
        PRR_Vec_minus(k) = Relative_Velocity(k) + UserVel(4);
        

    end  % for k = 1:NumberGPSMeasurements

    ys_kminus_0 = [PR_Vec_minus_0'; PRR_Vec_minus_0'];
    ys_kminus_i = [PR_Vec_minus_i(:,:); PRR_Vec_minus_i(:,:)];
    
    % find the sum of sigma points for the measurement prediction
   

    W = ones(1,2*Na+1);
    W(1,1) = W_0_m;
    W(1,2:2*Na+1) = W_i_m;

    Y = zeros(MeasurementNoiseStates,2*Na+1);
    Y(:,1) = ys_kminus_0(1:MeasurementNoiseStates);
    Y(:,2:2*Na+1) = ys_kminus_i(1:MeasurementNoiseStates,:);
    y_hat_kminus = (W*Y')';

    nx = length(x_hat_kminus); ny = length(y_hat_kminus); nw = length(W);
    Py_kminus=((ones(ny,1)*W).*(Y-y_hat_kminus*ones(1,nw)))*(Y-y_hat_kminus*ones(1,nw))';
    Pxy_kminus =((ones(nx,1)*W).*(X-x_hat_kminus*ones(1,nw)))*(Y-y_hat_kminus*ones(1,nw))';

    %% Py_kminus is equivalent to HPxH'+R 
    %% Pxy_kminus PxH' 
    %% therefor Hequiv = (inv(Px_kminus)*Pxy_kminus)'
    % calculate 'H' by normalizing Pxy
    Hequiv = (inv(Px_kminus) * Pxy_kminus)';
    Hequiv2(1:NumberGPSMeasurements,1:3) = Hequiv(1:NumberGPSMeasurements,1:3);
    Hequiv2(1:NumberGPSMeasurements,4) = Hequiv(1:NumberGPSMeasurements,7);
    
    
    
    [lat,lon] = ECEF2LLH(ApproxPos);
    Tecef2ned2 = T_ECEF2NED(lon,lat);
    Tecef2ned2(4,1:3) = [0 0 0];
    Tecef2ned2(1:4,4) = [0 0 0 1];
    H_ltp = Hequiv2 * Tecef2ned2';
        
    % calculate covariance matrix (AA) and transform to local coords
    AA = inv(H_ltp' * H_ltp);
    
    % calculate DOPs
    var_x = AA(1,1);
    var_y = AA(2,2);
    var_z = AA(3,3);
    var_dt = AA(4,4);
    DOP_UKF(Epoch_lo,1) = sqrt(var_x + var_y + var_z + var_dt);
    DOP_UKF(Epoch_lo,2) = sqrt(var_x + var_y + var_z);
    DOP_UKF(Epoch_lo,3) = sqrt(var_x + var_y);
    DOP_UKF(Epoch_lo,4) = sqrt(var_z);
    DOP_UKF(Epoch_lo,5) = sqrt(var_dt);
    
    
    % calculate kalman gain
    K_k = Pxy_kminus * inv(Py_kminus);
    %K_k = (Pxy_kminus / Sy_kminus') / Sy_kminus;

    % apply correction
    z_k = y_k - y_hat_kminus;
    z_save(Epoch_lo,:) = z_k;
    

    
    x_hat_kplus = x_hat_kminus + K_k * (z_k);

    Px_kplus = Px_kminus - K_k * Py_kminus * K_k';

    
       
    %% calculate EKF solution for comparisson
    
    EKF_x_hat_kminus = EKF_x_hat_kplus;
    EKF_Px_kminus = EKF_Px_kplus;
    
    EKF_z = [PR_Vec(1:NumberGPSMeasurements)';PRR_Vec(1:NumberGPSMeasurements)'];
    EKF_z = ([PR_Vec(1:NumberGPSMeasurements) PRR_Vec(1:NumberGPSMeasurements)]' - [PR_Vec_minus(1:NumberGPSMeasurements) PRR_Vec_minus(1:NumberGPSMeasurements)]');
    
    EKF_z_save(Epoch_lo,:) = EKF_z;
    
    [EKF_x_hat_kplus, EKF_Px_kplus, EKF_v_out, EKF_s2_out] = ...
        GARD_EvaluateKF(gps_dt, EKF_x_hat_kminus, EKF_Px_kminus, ...
        EKF_phi, EKF_H, EKF_z, EKF_Q, EKF_R);
    
    
    EKF_x_hat_save(Epoch_lo,:) = EKF_x_hat_kplus;
    EKF_P_save(Epoch_lo,:) = diag(EKF_Px_kplus);
    
    
    %% do the sub filter solutions
    for SubSolution = 1:NumberSubFilters


        % form the PR and CP vectors with one measurement left
        % out

        PR_SubVec(1:SubSolution-1) = PR_Vec(1:SubSolution-1);
        PR_SubVec(SubSolution:NumberSubMeasurements) = PR_Vec(SubSolution+1:NumberGPSMeasurements);

        PRR_SubVec(1:SubSolution-1) = PRR_Vec(1:SubSolution-1);
        PRR_SubVec(SubSolution:NumberSubMeasurements) = PRR_Vec(SubSolution+1:NumberGPSMeasurements);

        SVPos_Sub(1:SubSolution-1,:) = SVPos(1:SubSolution-1,:);
        SVPos_Sub(SubSolution:NumberSubMeasurements,:) = SVPos(SubSolution+1:NumberGPSMeasurements,:);

        SVVel_Sub(1:SubSolution-1,:) = SVVel(1:SubSolution-1,:);
        SVVel_Sub(SubSolution:NumberSubMeasurements,:) = SVVel(SubSolution+1:NumberGPSMeasurements,:);


        % formulate the measurment vector
        y_k_Sub = [PR_SubVec(1:NumberSubMeasurements)';PRR_SubVec(1:NumberSubMeasurements)'];



        for k = 1:NumberSubMeasurements
            % find apriori estimate of pseudorange for each sigma point

            % zero-th sigma point


            % Get User position in ECEF
            UserPos(1:3) = [xs_0_k(1);xs_0_k(2);xs_0_k(3)];
            UserPos(4) = xs_0_k(7);
            UserVel(1:3) =  [xs_0_k(4);xs_0_k(5);xs_0_k(6)];
            UserVel(4) = xs_0_k(8);

            geo_range_to_sat = sqrt((SVPos_Sub(k,1) - UserPos(1))^2 + (SVPos_Sub(k,2) - UserPos(2))^2 + (SVPos_Sub(k,3) - UserPos(3))^2);
            geo_vel_to_sat = (SVVel_Sub(k,1) - UserVel(1))*(SVPos_Sub(k,1)-UserPos(1)) + ...
                             (SVVel_Sub(k,2) - UserVel(2))*(SVPos_Sub(k,2)-UserPos(2)) + ...
                             (SVVel_Sub(k,3) - UserVel(3))*(SVPos_Sub(k,3)-UserPos(3));

        %% calculate measurement predicition
            % pseudorange prediction
            PR_Vec_minus_0_Sub(k) = geo_range_to_sat + UserPos(4) + xs_0(NumberStates+ProcessNoiseStates+k);% + UserVel(4) * gps_dt;  % geometric range + c * delta_T
            %predicted relative velocity of sv and receiver
            Relative_Velocity_Sub(k) = geo_vel_to_sat/geo_range_to_sat;
            PRR_Vec_minus_0_Sub(k) = Relative_Velocity_Sub(k) + UserVel(4) + xs_0(NumberStates+ProcessNoiseStates+MeasurementNoiseStates/2+k);

            for i=1:2*Na
                % Get User position in ECEF
                UserPos(1:3) = [xs_i_k(1,i);xs_i_k(2,i);xs_i_k(3,i)];
                UserPos(4) = xs_i_k(7,i);
                UserVel(1:3) =  [xs_i_k(4,i);xs_i_k(5,i);xs_i_k(6,i)];
                UserVel(4) = xs_i_k(8,i);


                geo_range_to_sat = sqrt((SVPos_Sub(k,1) - UserPos(1))^2 + (SVPos_Sub(k,2) - UserPos(2))^2 + (SVPos_Sub(k,3) - UserPos(3))^2);
                geo_vel_to_sat = (SVVel_Sub(k,1) - UserVel(1))*(SVPos_Sub(k,1)-UserPos(1)) + ...
                                 (SVVel_Sub(k,2) - UserVel(2))*(SVPos_Sub(k,2)-UserPos(2)) + ...
                                 (SVVel_Sub(k,3) - UserVel(3))*(SVPos_Sub(k,3)-UserPos(3));

                PR_Vec_minus_i_Sub(k,i) = geo_range_to_sat + UserPos(4) + xs_i(NumberStates+ProcessNoiseStates+k,i);% + UserVel(4) * gps_dt + xs_i(NumberStates+ProcessNoiseStates+k-1,i);  % geometric range + c * delta_T

                %predicted relative velocity of sv and receiver
                Relative_Velocity_Sub(k) = geo_vel_to_sat/geo_range_to_sat;
                PRR_Vec_minus_i_Sub(k,i) = Relative_Velocity_Sub(k) + UserVel(4) + xs_i(NumberStates+ProcessNoiseStates+MeasurementNoiseStates/2+k,i);
            end % for i=1:2*Na

            % calculate EKF H-matrix
            UserPos(1:4) = EKF_x_hat_kplus(1:4);
            UserVel(1:4) = EKF_x_hat_kplus(5:8);



            for m = 1:3
                 ele(m) =  SVPos(k,m) - UserPos(m);
            end    

            r_VecCalc_Sub(k) =  norm(ele);   

            EKF_H_Sub(k,1) =  -ele(1)/r_VecCalc(k);
            EKF_H_Sub(k,2) =  -ele(2)/r_VecCalc(k);
            EKF_H_Sub(k,3) =  -ele(3)/r_VecCalc(k);
            EKF_H_Sub(k,4) = 1;   
            EKF_H_Sub(k,5) = 0;
            EKF_H_Sub(k,6) = 0;
            EKF_H_Sub(k,7) = 0;
            EKF_H_Sub(k,8) = 0;

            EKF_H_Sub(k+NumberSubMeasurements,1) = 0;
            EKF_H_Sub(k+NumberSubMeasurements,2) = 0;
            EKF_H_Sub(k+NumberSubMeasurements,3) = 0;
            EKF_H_Sub(k+NumberSubMeasurements,4) = 0;   
            EKF_H_Sub(k+NumberSubMeasurements,5) = -ele(1)/r_VecCalc(k);
            EKF_H_Sub(k+NumberSubMeasurements,6) = -ele(2)/r_VecCalc(k);
            EKF_H_Sub(k+NumberSubMeasurements,7) = -ele(3)/r_VecCalc(k);
            EKF_H_Sub(k+NumberSubMeasurements,8) = 1;

            % find apriori estimate of pseudorange
            PR_Vec_minus_Sub(k) = r_VecCalc(k) + UserPos(4) + UserVel(4) * gps_dt;  % geometric range + c * delta_T
            %predicted relative velocity of sv and receiver
            r_VecCalcVel_Sub(k) = (SVVel_Sub(k,1) - UserVel(1))*(SVPos_Sub(k,1)-UserPos(1)) + ...
                                  (SVVel_Sub(k,2) - UserVel(2))*(SVPos_Sub(k,2)-UserPos(2)) + ...
                                  (SVVel_Sub(k,3) - UserVel(3))*(SVPos_Sub(k,3)-UserPos(3));
            Relative_Velocity_Sub(k) = r_VecCalcVel_Sub(k)/r_VecCalc_Sub(k);
            PRR_Vec_minus_Sub(k) = Relative_Velocity_Sub(k) + UserVel(4);


        end  % for k = 1:NumberGPSMeasurements


        SV_Used(Epoch_lo,:) = SV_Vec(1:NumberGPSMeasurements);
        SV_Visible(Epoch_lo,1:length(PR_Vec)) = SV_Vec;

        ys_kminus_0_Sub = [PR_Vec_minus_0_Sub'; PRR_Vec_minus_0_Sub'];
        ys_kminus_i_Sub = [PR_Vec_minus_i_Sub(:,:); PRR_Vec_minus_i_Sub(:,:)];

        % find the sum of sigma points for the measurement prediction


        W = ones(1,2*Na+1);
        W(1,1) = W_0_m;
        W(1,2:2*Na+1) = W_i_m;

        Y = zeros(MeasurementNoiseStates-2,2*Na+1);
        Y(:,1) = ys_kminus_0_Sub(1:MeasurementNoiseStates-2);
        Y(:,2:2*Na+1) = ys_kminus_i_Sub(1:MeasurementNoiseStates-2,:);
        y_hat_kminus_Sub = (W*Y')';

        nx = length(x_hat_kminus); ny = length(y_hat_kminus_Sub); nw = length(W);
        Py_kminus_Sub=((ones(ny,1)*W).*(Y-y_hat_kminus_Sub*ones(1,nw)))*(Y-y_hat_kminus_Sub*ones(1,nw))';
        Pxy_kminus_Sub =((ones(nx,1)*W).*(X-x_hat_kminus*ones(1,nw)))*(Y-y_hat_kminus_Sub*ones(1,nw))';

        % calculate kalman gain
        K_k_Sub = Pxy_kminus_Sub * inv(Py_kminus_Sub);
        %K_k = (Pxy_kminus / Sy_kminus') / Sy_kminus;

        % apply correction
        z_k_Sub = y_k_Sub - y_hat_kminus_Sub;
        %z_save_Sub(Epoch_lo,:) = z_k;



        x_hat_kplus_Sub(:,SubSolution) = x_hat_kminus + K_k_Sub * (z_k_Sub);

        Px_kplus_Sub(:,:,SubSolution) = Px_kminus - K_k_Sub * Py_kminus_Sub * K_k_Sub';




        EKF_z_Sub = ([PR_SubVec(1:NumberGPSMeasurements-1) PRR_SubVec(1:NumberGPSMeasurements-1)]' - ...
            [PR_Vec_minus_Sub(1:NumberGPSMeasurements-1) PRR_Vec_minus_Sub(1:NumberGPSMeasurements-1)]');

        [EKF_x_hat_kplus_Sub(:,SubSolution), EKF_Px_kplus_Sub(:,:,SubSolution), EKF_v_out_Sub, EKF_s2_out_Sub] = ...
        GARD_EvaluateKF(gps_dt, EKF_x_hat_kminus, EKF_Px_kminus, ...
        EKF_phi, EKF_H_Sub, EKF_z_Sub, EKF_Q, EKF_R_Sub);



    end %% sub solutions

    % form the solution separation vectors
    for j = 1:NumberSubFilters
        % note that only the position estimates are used - not
        % clock or velocity
        %X_ned = Tecef2ned * x_hat_kplus(1:3);
        %X_ned_Sub = Tecef2ned * x_hat_kplus_Sub(1:3,j);
        P_ned = abs(Tecef2ned * Px_kplus(1:3,1:3));
        P_ned_Sub = abs(Tecef2ned * Px_kplus_Sub(1:3,1:3,j));
        
        NED_ss = Tecef2ned * (x_hat_kplus(1:3) - x_hat_kplus_Sub(1:3,j));
        UKF_Beta_ss(:,j) = NED_ss(1:2);
        UKF_B_ss(:,:,j) = abs(P_ned_Sub(1:2,1:2) - P_ned(1:2,1:2));

        %UKF_lambda_ss(Epoch_lo,j) = UKF_Beta_ss(:,j)' * pinv(UKF_B_ss(:,:,j)) * UKF_Beta_ss(:,j);
        UKF_lambda_ss(Epoch_lo,j) = UKF_Beta_ss(:,j)' * UKF_Beta_ss(:,j);

        UKF_B_lambda = eigs(UKF_B_ss(:,:,j));
        UKF_TD_H(Epoch_lo,j) = sqrt(max(UKF_B_lambda)) * abs(norminv(PFalseAlarm/NumberGPSMeasurements,0,1));

        if(UKF_lambda_ss(Epoch_lo,j) > UKF_TD_H(Epoch_lo,j))
            disp(sprintf('H-Fault detected at Epoch %d on Sub-filter %d',Epoch_lo,j));
        end

        %UKF_PPL_sub(Epoch_lo,j) = sqrt(Px_kplus_Sub(1,1,j)^2 + Px_kplus_Sub(2,2,j)^2 + Px_kplus_Sub(3,3,j)^2) + TD(Epoch_lo,j);

        UKF_Beta_ss_V(:,j) = NED_ss(3);
        UKF_B_ss_V(:,:,j) = P_ned_Sub(3,3) - P_ned(3,3);

        UKF_lambda_ss_V(Epoch_lo,j) = UKF_Beta_ss_V(:,j)' * pinv(UKF_B_ss_V(:,:,j)) * UKF_Beta_ss_V(:,j);

        UKF_B_lambda_V = eigs(UKF_B_ss_V(:,:,j));
        UKF_TD_V(Epoch_lo,j) = sqrt(max(UKF_B_lambda_V)) * abs(norminv(PFalseAlarm/NumberGPSMeasurements,0,1));

        if(UKF_lambda_ss_V(Epoch_lo,j) > UKF_TD_H(Epoch_lo,j))
            disp(sprintf('V-Fault detected at Epoch %d on Sub-filter %d',Epoch_lo,j));
        end

        %% this HPL represents the fault-free (H0) hypothesis. 
        Sigma_MD_H = abs(norminv(PMissedDetection,0,1));
        Sigma_MD_V = abs(norminv(PMissedDetection,0,1));
        UKF_HPL_sub(Epoch_lo,j) = Sigma_MD_H * sqrt(P_ned(1,1)^2 + P_ned(2,2)^2) + UKF_TD_H(Epoch_lo,j);
        UKF_VPL_sub(Epoch_lo,j) = Sigma_MD_V * sqrt(P_ned(3,3)^2) + UKF_TD_V(Epoch_lo,j);

        %% todo - calculate the Fault-in progress (h1) hypothesis based
        %% HPL_H1.


        EKF_Beta_ss(:,j) = EKF_x_hat_kplus(1:3) - EKF_x_hat_kplus_Sub(1:3,j);
        EKF_B_ss(:,:,j) = EKF_Px_kplus_Sub(1:3,1:3,j) - EKF_Px_kplus(1:3,1:3);

        %EKF_lamda_ss(j) = EKF_Beta_ss(:,j)' * pinv(EKF_B_ss(:,:,j)) * EKF_Beta_ss(:,j);
        EKF_lamda_ss(Epoch_lo,j) = EKF_Beta_ss(:,j)' * EKF_Beta_ss(:,j);

        EKF_B_lambda = eigs(EKF_B_ss(:,:,j));
        EKF_TD(Epoch_lo,j) = sqrt(max(EKF_B_lambda)) * abs(norminv(PFalseAlarm/NumberSubMeasurements,0,1));

        EKF_PPL_sub(Epoch_lo,j) = sqrt(EKF_Px_kplus_Sub(1,1,j)^2 + EKF_Px_kplus_Sub(2,2,j)^2 + EKF_Px_kplus_Sub(3,3,j)^2) + EKF_TD(Epoch_lo,j);


        EKF_P_ned = Tecef2ned * EKF_Px_kplus_Sub(1:3,1:3,j);

        EKF_HPL_sub(Epoch_lo,j) = sqrt(EKF_P_ned(1,1)^2 + EKF_P_ned(2,2)^2) + EKF_TD(Epoch_lo,j);
        EKF_VPL_sub(Epoch_lo,j) = sqrt(EKF_P_ned(3,3)^2) + EKF_TD(Epoch_lo,j);


    end
%    UKF_PPL(Epoch_lo) = max(UKF_PPL_sub(Epoch_lo,:));
    UKF_HPL(Epoch_lo) = max(UKF_HPL_sub(Epoch_lo,:));
    UKF_VPL(Epoch_lo) = max(UKF_VPL_sub(Epoch_lo,:));

%    EKF_PPL(Epoch_lo) = max(EKF_PPL_sub(Epoch_lo,:));
    EKF_HPL(Epoch_lo) = max(EKF_HPL_sub(Epoch_lo,:));
    EKF_VPL(Epoch_lo) = max(EKF_VPL_sub(Epoch_lo,:));


        
    %% calculate solution using least squares for comparisson
    [LSQ_Solution(Epoch_lo,:), LSQ_Variance(Epoch_lo,:), LSQ_NumIterations(Epoch_lo), ...
        LSQ_ResidualVector(Epoch_lo,:), LSQ_M, LSQ_Fail(Epoch_lo), ...
        LSQ_limit(Epoch_lo), LSQ_DOP(Epoch_lo,:)] = GARD_LSQ([ApproxPos 0],NumberGPSMeasurements, PR_Vec_raw(1:NumberGPSMeasurements),SVPos(1:NumberGPSMeasurements,:));
    
   %% do RAIM Parity on LSQ solution - Note, you must run
   %% GARDSim_CalculateThresholdPbias before using this.
   [BadGeometry(Epoch_lo), LSQ_RAIM_ALERT(Epoch_lo), LSQ_SLOPE_Max(Epoch_lo), LSQ_r(Epoch_lo), LSQ_Td(Epoch_lo), LSQ_RAIM_HPL(Epoch_lo),LSQ_RAIM_VPL(Epoch_lo), LSQ_FaultySatFDI(Epoch_lo)] = ...
       GARDSim_RAIMParity(a, lambdatrue, NumberGPSMeasurements,PFalseAlarm,GPS_PR_UERE,556,LSQ_ResidualVector(Epoch_lo,:)',LSQ_M*Tecef2ned2');
       
    
    SSE(Epoch_lo) = LSQ_ResidualVector(Epoch_lo,:)*LSQ_ResidualVector(Epoch_lo,:)';
    
    if(LSQ_RAIM_ALERT(Epoch_lo))
       disp(sprintf('RAIM Error Detected at epoch %d',Epoch_lo)); 
    end
    
 
    

    
    %save results
    t_save(Epoch_lo) = Epoch_lo;
    x_hat_save(Epoch_lo,:) = x_hat_kplus;
    P_save(Epoch_lo,:) = diag(Px_kplus);


    % copy updated state to high-speed loop state for next round
    x_hat_kminus = x_hat_kplus;
    Px_kminus = Px_kplus;
    
    
        
    %% convert results to LLH
    [x_save_llh(Epoch_lo,1),x_save_llh(Epoch_lo,2),x_save_llh(Epoch_lo,3)] = ECEF2LLH(x_hat_save(Epoch_lo,1:3));
    Tecef2ned = T_ECEF2NED(x_save_llh(Epoch_lo,2),x_save_llh(Epoch_lo,1));
    

    P_save_NED(Epoch_lo,1:3) = abs(Tecef2ned*P_save(Epoch_lo,1:3)');
    S_save_NED(Epoch_lo,1:3) = sqrt(P_save_NED(Epoch_lo,1:3));

    EKF_P_save_NED(Epoch_lo,1:3) = abs(Tecef2ned*EKF_P_save(Epoch_lo,1:3)');
    EKF_S_save_NED(Epoch_lo,1:3) = sqrt(EKF_P_save_NED(Epoch_lo,1:3));
    
    EKF_P_save_NED(Epoch_lo,1:3) = abs(Tecef2ned*EKF_P_save(Epoch_lo,1:3)');
    EKF_S_save_NED(Epoch_lo,1:3) = sqrt(EKF_P_save_NED(Epoch_lo,1:3));
    
    %% calculate velocity in North-East-Down

    x_save_vel(Epoch_lo,:) = Tecef2ned*x_hat_save(Epoch_lo,4:6)';
    P_save_vel(Epoch_lo,:) = abs(Tecef2ned*P_save(Epoch_lo,4:6)');
    S_save_vel(Epoch_lo,:) = sqrt(P_save_vel(Epoch_lo,1:3));
    
    %% calculate position error
    ECEFError_UKF(Epoch_lo,:) = x_hat_save(Epoch_lo,1:3) - meanECEF;
    ECEFError_LSQ(Epoch_lo,:) = LSQ_Solution(Epoch_lo,1:3) - meanECEF;
    ECEFError_EKF(Epoch_lo,:) = EKF_x_hat_save(Epoch_lo,1:3) - meanECEF;
    
    %% calculate velocity in North-East-Down
    [lat,lon] = ECEF2LLH(meanECEF);
    Tecef2ned = T_ECEF2NED(lon,lat);
    
    NEDError_UKF(Epoch_lo,:) = Tecef2ned * ECEFError_UKF(Epoch_lo,:)';
    NEDError_LSQ(Epoch_lo,:) = Tecef2ned * ECEFError_LSQ(Epoch_lo,:)';
    NEDError_EKF(Epoch_lo,:) = Tecef2ned * ECEFError_EKF(Epoch_lo,:)';
    
%     pos_error_llh(Epoch_lo,:) = x_save_llh(Epoch_lo,:) - pos_truth_llh(2:4,Epoch_lo*100)';
%     pos_error_llh(Epoch_lo,1) = pos_error_llh(Epoch_lo,1) * RM;
%     pos_error_llh(Epoch_lo,2) = pos_error_llh(Epoch_lo,2) * RP * cos(pos_truth_llh(2,Epoch_lo*100));
    
    
%     vel_error_ned(Epoch_lo,:) = x_save_vel(Epoch_lo,:) - vel_truth(2:4,Epoch_lo*100)';

%% uncomment the below line if hte 11-state filter is used.
%    x_save_acc(Epoch_lo,:) = Tecef2ned*x_hat_save(Epoch_lo,9:11)';
    
    %% update R-matrix
%     if(Epoch_lo > 10)
%         for k = 1:NumberGPSMeasurements
%             R(k,k) = std(abs(z_save(:,k)))^2;
%             R(k+NumberGPSMeasurements,k+NumberGPSMeasurements) = std(abs(z_save(:,k+NumberGPSMeasurements)))^2;
%         end
%     end
%     
    
    
    
    
    disp(sprintf('Completed Epoch %d',Epoch_lo));

    
    
    
end



%% plot results
% figure();
% plot3(x_hat_save(:,1),x_hat_save(:,2),x_hat_save(:,3));

% figure();
% plot(x_save_llh(:,2)*180/pi,x_save_llh(:,1)*180/pi,'r*');
% xlabel('Longitude (deg)');
% ylabel('Latitude (deg)');
% grid on;
% title('GPS UKF Position Solution');



% figure();
% subplot(3,1,1),plot(t_save,x_save_llh(:,1)*180/pi);
% title('Position Solution');
% ylabel('Latitude (deg)');
% subplot(3,1,2),plot(t_save,x_save_llh(:,2)*180/pi);
% ylabel('Longitude (deg)');
% subplot(3,1,3),plot(t_save,x_save_llh(:,3));
% ylabel('Height (m-WGS84)');
% xlabel('Time (sec)');
% % 
% figure();
% subplot(3,1,1),plot(t_save,x_save_vel(:,1)); hold on; grid on;
% subplot(3,1,1),plot(t_save,2*S_save_vel(:,1),'r');
% subplot(3,1,1),plot(t_save,-2*S_save_vel(:,1),'r');
% title('Velocity Solution');
% ylabel('North (m/s)');
% subplot(3,1,2),plot(t_save,x_save_vel(:,2)); hold on; grid on;
% subplot(3,1,2),plot(t_save,2*S_save_vel(:,2),'r');
% subplot(3,1,2),plot(t_save,-2*S_save_vel(:,2),'r');
% ylabel('East (m/s)');
% subplot(3,1,3),plot(t_save,x_save_vel(:,3)); hold on; grid on;
% subplot(3,1,3),plot(t_save,2*S_save_vel(:,3),'r');
% subplot(3,1,3),plot(t_save,-2*S_save_vel(:,3),'r');
% ylabel('Down (m/s)');
% xlabel('Time (sec)');



% 
% subplot(3,1,1),plot(t_save,pos_error_llh(:,1));
% title('Position Error');
% hold on;
% subplot(3,1,1),plot(t_save,2*sqrt(P_save_llh(:,1)),'r');
% subplot(3,1,1),plot(t_save,-2*sqrt(P_save_llh(:,1)),'r');
% 
% subplot(3,1,2),plot(t_save,pos_error_llh(:,2));
% hold on;
% subplot(3,1,2),plot(t_save,2*sqrt(P_save_llh(:,2)),'r');
% subplot(3,1,2),plot(t_save,-2*sqrt(P_save_llh(:,2)),'r');
% 
% subplot(3,1,3),plot(t_save,pos_error_llh(:,3));
% hold on;
% subplot(3,1,3),plot(t_save,2*sqrt(P_save_llh(:,3)),'r');
% subplot(3,1,3),plot(t_save,-2*sqrt(P_save_llh(:,3)),'r');
% 
% 
% figure();
% subplot(3,1,1),plot(t_save,x_save_vel(:,1));
% title('Velocity');
% subplot(3,1,2),plot(t_save,x_save_vel(:,2));
% subplot(3,1,3),plot(t_save,x_save_vel(:,3));
% 
% figure();
% subplot(3,1,1),plot(t_save,vel_error_ned(:,1));
% title('Velocity Error');
% subplot(3,1,2),plot(t_save,vel_error_ned(:,2));
% subplot(3,1,3),plot(t_save,vel_error_ned(:,3));
% 
% figure();
% subplot(3,1,1),plot(t_save,x_save_acc(:,1));
% title('Acceleration');
% subplot(3,1,2),plot(t_save,x_save_acc(:,2));
% subplot(3,1,3),plot(t_save,x_save_acc(:,3));
% 
% 


% %% plot static positioning errors - UKF vs LSQ
% figure();
% subplot(3,1,1),plot(t_save/60,abs(NEDError_UKF(:,1)),'b'); hold on;
% subplot(3,1,1),plot(t_save/60,2*S_save_NED(:,1),'b--');
% %subplot(3,1,1),plot(t_save/60,-2*S_save_NED(:,1),'b--');
% subplot(3,1,1),plot(t_save/60,abs(NEDError_LSQ(:,1)),'r');
% subplot(3,1,1),plot(t_save/60,LSQ_DOP(:,3)*GPS_PR_UERE*2,'r--');
% %subplot(3,1,1),plot(t_save/60,-LSQ_DOP(:,3)*GPS_PR_UERE*2,'r--');
% 
% subplot(3,1,1),plot(t_save/60,abs(NEDError_EKF(:,1)),'g');
% subplot(3,1,1),plot(t_save/60,2*EKF_S_save_NED(:,1),'g--');
% 
% axis([t_save(1)/60,t_save(Epoch_lo)/60,00,40]);
% grid on;
% title('Static Positioning UKF and LSQ Errors');
% legend('UKF Error','UKF 2-\sigma bound','LSQ Error','LSQ 2-\sigma bound','EKF Error','EKF 2-\sigma bound');
% ylabel('North Error (m)');
% xlabel('Test Time (mins)');
% 
% subplot(3,1,2),plot(t_save/60,abs(NEDError_UKF(:,2)),'b'); hold on;
% subplot(3,1,2),plot(t_save/60,2*S_save_NED(:,2),'b--');
% %subplot(3,1,2),plot(t_save/60,-2*S_save_NED(:,2),'b--');
% subplot(3,1,2),plot(t_save/60,abs(NEDError_LSQ(:,2)),'r'); 
% subplot(3,1,2),plot(t_save/60,LSQ_DOP(:,3)*GPS_PR_UERE*2,'r--');
% %subplot(3,1,2),plot(t_save/60,-LSQ_DOP(:,3)*GPS_PR_UERE*2,'r--');
% 
% subplot(3,1,2),plot(t_save/60,abs(NEDError_EKF(:,2)),'g');
% subplot(3,1,2),plot(t_save/60,2*EKF_S_save_NED(:,2),'g--');
% 
% axis([t_save(1)/60,t_save(Epoch_lo)/60,0,40]);
% grid on;
% ylabel('East Error (m)');
% xlabel('Test Time (mins)');
% subplot(3,1,3),plot(t_save/60,abs(NEDError_UKF(:,3)),'b'); hold on;
% subplot(3,1,3),plot(t_save/60,2*S_save_NED(:,3),'b--');
% %subplot(3,1,3),plot(t_save/60,-2*S_save_NED(:,3),'b--');
% subplot(3,1,3),plot(t_save/60,abs(NEDError_LSQ(:,3)),'r');
% subplot(3,1,3),plot(t_save/60,LSQ_DOP(:,4)*GPS_PR_UERE*2,'r--');
% %subplot(3,1,3),plot(t_save/60,-LSQ_DOP(:,4)*GPS_PR_UERE*2,'r--');
% 
% subplot(3,1,3),plot(t_save/60,abs(NEDError_EKF(:,3)),'g');
% subplot(3,1,3),plot(t_save/60,2*EKF_S_save_NED(:,3),'g--');
% 
% axis([t_save(1)/60,t_save(Epoch_lo)/60,0,40]);
% grid on;
% ylabel('Down Error (m)');
% xlabel('Test Time (mins)');
% 


% 
% figure();
% subplot(3,1,1),plot(t_save/60,NEDError_UKF(:,1),'b'); hold on;
% subplot(3,1,1),plot(t_save/60,2*S_save_NED(:,1),'r');
% subplot(3,1,1),plot(t_save/60,-2*S_save_NED(:,1),'r'); 
% 
% grid on;
% title('UKF Error Bounds');
% ylabel('North Error (m)');
% subplot(3,1,2),plot(t_save/60,NEDError_UKF(:,2),'b'); hold on;
% subplot(3,1,2),plot(t_save/60,2*S_save_NED(:,2),'r'); 
% subplot(3,1,2),plot(t_save/60,-2*S_save_NED(:,2),'r'); 
% 
% grid on;
% ylabel('East Error (m)');
% subplot(3,1,3),plot(t_save/60,NEDError_UKF(:,3),'b'); hold on;
% subplot(3,1,3),plot(t_save/60,2*S_save_NED(:,3),'r');
% subplot(3,1,3),plot(t_save/60,-2*S_save_NED(:,3),'r');
% 
% grid on;
% ylabel('Down Error (m)');
% xlabel('Test Time (mins)');

% 
% figure();
% plot(t_save/60,x_hat_save(:,7))
% grid on;
% xlabel('Test Time (mins)');
% ylabel('Clock Estimates (m)');
% title('Receiver Clock Bias');

%% plot residuals
% figure();
% subplot(2,1,1),plot(t_save/60,z_save(:,1:NumberGPSMeasurements));
% axis([0 Epoch_lo/60 -3 3]);
% ylabel('UKF Residuals');
% xlabel('Test Time (mins)');
% legend(num2str((SV_Vec(1:NumberGPSMeasurements)')));
% grid on;
% subplot(2,1,2),plot(t_save/60,LSQ_ResidualVector(:,1:NumberGPSMeasurements));
% %axis([0 Epoch_lo/60 -3 3]);
% ylabel('LSQ Residuals');
% xlabel('Test Time (mins)');
% legend(num2str((SV_Vec(1:NumberGPSMeasurements)')));
% grid on;


% for i=1:NumberGPSMeasurements
%     figure();
%     plot(t_save/60,z_save(:,i),'b'); hold on;
%     plot(t_save/60,LSQ_ResidualVector(:,i),'r');
%     plot(t_save/60,EKF_z_save(:,i),'g');
%     xlabel('Test Time (mins)');
%     ylabel('Residual (m)');
%     legend('UKF','LSQ','EKF');
%     title(sprintf('Measurement Residual for SV%d',SV_Vec(i)))
%     grid on;
%     axis([t_save(StartTime)/60 t_save(EndTime)/60 -2 2]);
% end

% figure();
% plot(t_save/60,z_save(:,1:NumberGPSMeasurements));
% hold on;
% plot(t_save/60,LSQ_ResidualVector(:,1:NumberGPSMeasurements));
% legend(num2str((SV_Vec(1:NumberGPSMeasurements)')));
% grid on;
% xlabel('Test Time (min)');
% ylabel('Residuals');

%% plot clock estimate
% figure();
% plot(t_save/60,x_hat_save(:,7),'b');
% hold on;
% plot(t_save/60,LSQ_Solution(:,4),'r');
% grid on;
% plot(t_save/60,EKF_x_hat_save(:,4),'g');
% xlabel('Test Time (mins)');
% ylabel('Clock Estimates (m)');
% axis([0 Epoch_lo/60 6 16]);
% title('Receiver Clock Bias');
% legend('UKF','LSQ','EKF');

% %% plot DOPs
% figure();
% subplot(3,1,1),plot(t_save/60,DOP_UKF(:,3),'b'); hold on;
% subplot(3,1,1),plot(t_save/60,LSQ_DOP(:,3),'r'); grid on;
% ylabel('HDOP');
% title('DOP Values Calculated by UKF and Least-Squares');
% legend('UKF','LSQ');
% subplot(3,1,2),plot(t_save/60,DOP_UKF(:,4),'b'); hold on;
% subplot(3,1,2),plot(t_save/60,LSQ_DOP(:,4),'r'); grid on;
% ylabel('VDOP');
% 
% subplot(3,1,3),plot(t_save/60,DOP_UKF(:,5),'b'); hold on;
% subplot(3,1,3),plot(t_save/60,LSQ_DOP(:,5),'r'); grid on;
% ylabel('TDOP');
% xlabel('Test Time (minutes)');



%% calculate the RMS error
%Height_RMS = sqrt(sum(Height_error.^2)/NumberEpochsINS)'
North_RMS_LSQ = sqrt(sum(NEDError_LSQ(:,1).^2)/NumberEpochsGPS)
North_RMS_EKF = sqrt(sum(NEDError_EKF(:,1).^2)/NumberEpochsGPS)
North_RMS_UKF = sqrt(sum(NEDError_UKF(:,1).^2)/NumberEpochsGPS)

East_RMS_LSQ = sqrt(sum(NEDError_LSQ(:,2).^2)/NumberEpochsGPS)
East_RMS_EKF = sqrt(sum(NEDError_EKF(:,2).^2)/NumberEpochsGPS)
East_RMS_UKF = sqrt(sum(NEDError_UKF(:,2).^2)/NumberEpochsGPS)

Down_RMS_LSQ = sqrt(sum(NEDError_LSQ(:,3).^2)/NumberEpochsGPS)
Down_RMS_EKF = sqrt(sum(NEDError_EKF(:,3).^2)/NumberEpochsGPS)
Down_RMS_UKF = sqrt(sum(NEDError_UKF(:,3).^2)/NumberEpochsGPS)


North_RMS_LSQ_sub = sqrt(sum(NEDError_LSQ(30:length(NEDError_LSQ),1).^2)/(NumberEpochsGPS-30))
North_mean_LSQ_sub = mean(NEDError_LSQ(30:length(NEDError_LSQ),1))
North_std_LSQ_sub = std(NEDError_LSQ(30:length(NEDError_LSQ),1)-North_mean_LSQ_sub)

North_RMS_EKF_sub = sqrt(sum(NEDError_EKF(30:length(NEDError_LSQ),1).^2)/(NumberEpochsGPS-30))
North_mean_EKF_sub = mean(NEDError_EKF(30:length(NEDError_EKF),1))
North_std_EKF_sub = std(NEDError_EKF(30:length(NEDError_EKF),1)-North_mean_EKF_sub)

North_RMS_UKF_sub = sqrt(sum(NEDError_UKF(30:length(NEDError_UKF),1).^2)/(NumberEpochsGPS-30))
North_mean_UKF_sub = mean(NEDError_UKF(30:length(NEDError_UKF),1))
North_std_UKF_sub = std(NEDError_UKF(30:length(NEDError_UKF),1)-North_mean_UKF_sub)


East_RMS_LSQ_sub = sqrt(sum(NEDError_LSQ(30:length(NEDError_LSQ),2).^2)/(NumberEpochsGPS-30))
East_mean_LSQ_sub = mean(NEDError_LSQ(30:length(NEDError_LSQ),2))
East_std_LSQ_sub = std(NEDError_LSQ(30:length(NEDError_LSQ),2)-East_mean_LSQ_sub)

East_RMS_EKF_sub = sqrt(sum(NEDError_EKF(30:length(NEDError_LSQ),2).^2)/(NumberEpochsGPS-30))
East_mean_EKF_sub = mean(NEDError_EKF(30:length(NEDError_EKF),2))
East_std_EKF_sub = std(NEDError_EKF(30:length(NEDError_EKF),2)-East_mean_EKF_sub)


East_RMS_UKF_sub = sqrt(sum(NEDError_UKF(30:length(NEDError_LSQ),2).^2)/(NumberEpochsGPS-30))
East_mean_UKF_sub = mean(NEDError_UKF(30:length(NEDError_UKF),2))
East_std_UKF_sub = std(NEDError_UKF(30:length(NEDError_UKF),2)-East_mean_UKF_sub)


Down_RMS_LSQ_sub = sqrt(sum(NEDError_LSQ(30:length(NEDError_LSQ),3).^2)/(NumberEpochsGPS-30))
Down_mean_LSQ_sub = mean(NEDError_LSQ(30:length(NEDError_LSQ),3))
Down_std_LSQ_sub = std(NEDError_LSQ(30:length(NEDError_LSQ),3)-Down_mean_LSQ_sub)

Down_RMS_EKF_sub = sqrt(sum(NEDError_EKF(30:length(NEDError_LSQ),3).^2)/(NumberEpochsGPS-30))
Down_mean_EKF_sub = mean(NEDError_EKF(30:length(NEDError_EKF),3))
Down_std_EKF_sub = std(NEDError_EKF(30:length(NEDError_EKF),3)-Down_mean_EKF_sub)

Down_RMS_UKF_sub = sqrt(sum(NEDError_UKF(30:length(NEDError_LSQ),3).^2)/(NumberEpochsGPS-30))
Down_mean_UKF_sub = mean(NEDError_UKF(30:length(NEDError_UKF),3))
Down_std_UKF_sub = std(NEDError_UKF(30:length(NEDError_UKF),3)-Down_mean_UKF_sub)


%% plot stanford diagrams
%% figure
HAL = 40;
% figure();hold on;
% plot(sqrt(NEDError_UKF(100:length(NEDError_UKF),1).^2+NEDError_UKF(100:length(NEDError_UKF),2).^2),UKF_HPL(100:length(NEDError_UKF)),'b.');
% plot(sqrt(NEDError_EKF(100:length(NEDError_EKF),1).^2+NEDError_EKF(100:length(NEDError_EKF),2).^2),EKF_HPL(100:length(NEDError_EKF)),'r.');
% plot(sqrt(NEDError_LSQ(:,1).^2+NEDError_LSQ(:,2).^2),LSQ_RAIM_HPL,'g.');
% %area([HAL 100],[HAL HAL],'FaceColor','r');
% plot([0 100],[HAL HAL],'k','LineWidth',2);
% plot([HAL HAL],[0 HAL],'k','LineWidth',2);
% axis([0 100 0 100]);
% text(12,5,'MI');
% text(52,5,'HMI');
% text(52,35,'MI');
% plot([0:3000],[0:3000],'k-','LineWidth',2);
% xlabel('Position Error (m)');
% ylabel('Protection Level (m)');
% legend('UKF','EKF','LSQ');
% grid on;
% title('Horizontal Stanford Plot');

GARD_PlotStanford(sqrt(NEDError_UKF(100:length(NEDError_UKF),1).^2+NEDError_UKF(100:length(NEDError_UKF),2).^2), ...
    UKF_HPL(100:length(NEDError_UKF))',HAL,1,100,'Horizontal Stanford Plot - UKF',1);

GARD_PlotStanford(sqrt(NEDError_EKF(100:length(NEDError_EKF),1).^2+NEDError_EKF(100:length(NEDError_EKF),2).^2), ...
    EKF_HPL(100:length(NEDError_EKF))',HAL,1,100,'Horizontal Stanford Plot - EKF',1);

GARD_PlotStanford(sqrt(NEDError_LSQ(:,1).^2+NEDError_LSQ(:,2).^2), ...
    LSQ_RAIM_HPL',HAL,1,100,'Horizontal Stanford Plot - LSQ',1);

VAL = 50;
figure();
plot(abs(NEDError_UKF(100:length(NEDError_UKF),3)),UKF_VPL(100:length(NEDError_UKF)),'b.');
hold on;
plot(abs(NEDError_EKF(100:length(NEDError_EKF),3)),EKF_VPL(100:length(NEDError_EKF)),'r.');
plot(abs(NEDError_LSQ(:,3)),LSQ_RAIM_VPL,'g.');
plot([0 100],[VAL VAL],'k','LineWidth',2);
plot([VAL VAL],[0 VAL],'k','LineWidth',2);
axis([0 100 0 100]);
plot([0:3000],[0:3000],'k-','LineWidth',2);
text(32,15,'MI');
text(72,25,'HMI');
text(72,65,'MI');
xlabel('Position Error (m)');
ylabel('Protection Level (m)');
legend('UKF','EKF','LSQ');
grid on;
title('Vertical Stanford Plot');

GARD_PlotStanford(abs(NEDError_UKF(100:length(NEDError_UKF),3)), ...
    UKF_VPL(100:length(NEDError_UKF))',VAL,1,100,'Vertical Stanford Plot - UKF');

GARD_PlotStanford(abs(NEDError_EKF(100:length(NEDError_EKF),3)), ...
    EKF_VPL(100:length(NEDError_EKF))',VAL,1,100,'Vertical Stanford Plot - EKF');

GARD_PlotStanford(abs(NEDError_LSQ(:,3)), ...
    LSQ_RAIM_VPL',VAL,1,100,'Vertical Stanford Plot - LSQ');

figure();
plot(t_save/60,UKF_HPL,'k-');
hold on;
plot(t_save/60,EKF_HPL,'k:');
plot(t_save/60,LSQ_RAIM_HPL,'k:','LineWidth',1.5);
xlabel('Test Time (mins)');
ylabel('Protection Level (m)');
title('Horizontal Protection Level');
legend('UKF','EKF','LSQ');
axis([StartTime/60 EndTime/60 0 250]);

figure();
plot(t_save/60,UKF_VPL,'k-');
hold on;
plot(t_save/60,EKF_VPL,'k:');
plot(t_save/60,LSQ_RAIM_VPL,'k:','LineWidth',1.5);
xlabel('Test Time (mins)');
ylabel('Protection Level (m)');
title('Vertical Protection Level');
legend('UKF','EKF','LSQ');
axis([StartTime/60 EndTime/60 0 250]);

% figure();
% plot(t_save/3600,DOP_UKF(:,3),'LineWidth',2)
% hold on;
% plot(t_save/3600,DOP_UKF(:,4),'r','LineWidth',2)
% grid on;
% axis([0 24 0 6]);
% xlabel('Hour of Day');
% ylabel('DOP');
% legend('HDOP','VDOP');
