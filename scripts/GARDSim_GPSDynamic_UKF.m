%% GPS Position Solution using UKF
% Written by Duncan Greer 2 Feb 2007
%
% $Id: GARDSim_GPSDynamic_UKF.m 4408 2011-04-03 11:49:35Z greerd $
%
%
%
%
%
% x1  = ECEF X
% x2  = ECEF Y
% x3  = ECEF Z
% x4  = ECEF X Velocity
% x5  = ECEF Y Velocity
% x6  = ECEF Z Velocity
% x7  = Receiver Clock Bias (Rb)
% x8  = Receiver Clock Drift Rate (Rf)
% x9  = ECEF X Acceleration
% x10 = ECEF Y Acceleration
% x11 = ECEF Z Acceleration
% x12 = ECEF X Jerk
% x13 = ECEF Z Jerk
% x14 = ECEF Z Jerk

%% setup simulation

% set number formatting for display
format long g;

% load GPS constants
GPSConstants;

%% Load data - Note, this mat file is generated by the commented code
%% below.
%load 'data/Ground_Test_Data/2Feb2007/flexpak.mat';
%load 'data/Ground_Test_Data/22Feb2007/flexpak.mat';
%load 'data/Simulator_Data/Mar_07/flexpak_2.mat';

%load 'data/Simulator_Data/Mar_07/sim_truth_2.mat';


%DataPath = 'data/Simulator_Data/Apr_08/data/sg_rnav_approach/';
DataPath = 'data/Simulator_Data/Apr_08/data/rnav_approach_long/';

% FileNamePrefix = 'novatel_080410022139';
% Year = '05';
% 
load(strcat(DataPath,'flexpak.mat'));
%load(strcat(DataPath,'sim_truth.mat'));
load(strcat(DataPath,'pos_truth_ecef.mat'));
load(strcat(DataPath,'pos_truth_llh.mat'));
load(strcat(DataPath,'vel_truth.mat'));

GPSTime_Start = 259200;

% TruthOffset = 39;

TruthOffset = round(GPSTime_Sec(1)-GPSTime_Start);

% % convert simtruth time (col 1) to gps seconds
% for i=1:length(sim_truth)
%     hrs_in = floor(sim_truth(i,1)/3600/1000);
%     min_in = floor(sim_truth(i,1)/60/1000);
%     sec_in = sim_truth(i,1)/1000 - hrs_in*3600 - min_in * 60;
%     [gpsweek_out(i), gpssec_out(i)] = ftime([07 03 01 hrs_in min_in sec_in]);
%     sim_truth(i,1) = gpssec_out(i);
% end

%bestpos_2 = GARD_ReadBestPos('data/Simulator_Data/Mar_07/bestpos_1416_2.txt');

% a hack for this file = approx pos is wrong
%ApproxPos = [-5046719.69001578,2568403.35951166,-2925318.76002602];
meanECEF =  [-5046773.35774802  2568446.08440315 -2925289.01760974];

%ALPHA = [9.3132E-09  0.0000E+00 -5.9605E-08  0.0000E+00];
%BETA = [9.0112D+04  0.0000E+00 -1.9661E+05  0.0000E+00];

% % exact alpha and beta values used on the simualtor
% ALPHA = [4.6566129e-9, 1.4901161e-9, -5.96046e-8,-5.96046e-8];
% BETA = [79872, 65536, -65536, -393216];

% 
% ALPHA(1) = 4.6566128999999998e-009
% ALPHA(2) = 1.4901161000000001e-008
% ALPHA(3) = -5.9604600000000002e-008
% ALPHA(4) = -5.9604600000000002e-008
% BETA(1) = 7.9872000000000000e+004
% BETA(2) = 6.5536000000000000e+004
% BETA(3) = -6.5536000000000000e+004
% BETA(4) = -3.9321600000000000e+005
            
% load observation and nav data
% [GPSTime_Week, GPSTime_Sec,NumberRinexObsTypes,ValidDataRinexObs,ApproxPos, Novatel_C1, Novatel_L1, Novatel_D1, Novatel_S1, Novatel_P2, Novatel_L2, Novatel_D2, Novatel_S2] = ReadRinexNovatel('data/Ground_Test_Data/2Feb2007/02020330.07O');
% [SV_Ephemeris, ALPHA, BETA] = freadnav('data/Ground_Test_Data/2Feb2007/02020330.07N');
% 

% [GPSTime_Week, GPSTime_Sec,NumberRinexObsTypes,ApproxPos, data] = ...
% ReadRinexGRS('data/Simulator_Data/Mar_07/nova0600_2.07O');
% Novatel_C1 = data.C1(:,:);
% Novatel_D1 = data.D1(:,:);
% Novatel_L1 = data.L1(:,:);
% Novatel_S1 = data.S1(:,:);
% clear data;
% [SV_Ephemeris, ALPHA, BETA] =
% freadnav('data/Simulator_Data/Mar_07/nova0600_2.07N');

% NumberEpochsGPS = size(Novatel_C1,2);
% gps_dt = 1;
% 
% NumberSVs = size(Novatel_C1,1);
% SVDontUse = zeros(1,NumberSVs);
% 
% % propogate satellite orbits and velocities
% disp('Calculating Satellite Orbits...');
% 
% % preallocate storage vectors for speed
% SV_X_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Y_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Z_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_T_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Xvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Yvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Zvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Tvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Xacc_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Yacc_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Zacc_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Tacc_Data = zeros(NumberEpochsGPS,NumberSVs);
% 
% for i=1:NumberEpochsGPS
%     for j=1:NumberSVs
%         [SV_X_Data(i,j), SV_Y_Data(i,j), SV_Z_Data(i,j), SV_T_Data(i,j), ValidPosData(i,j)] = ...
%                GPSOrbitPropagator(GPSTime_Week(i), GPSTime_Sec(i), j, SV_Ephemeris, 7500);
%         [SV_Xvel_Data(i,j), SV_Yvel_Data(i,j), SV_Zvel_Data(i,j), SV_Tvel_Data(i,j), ...
%          SV_Xacc_Data(i,j), SV_Yacc_Data(i,j), SV_Zacc_Data(i,j), SV_Tacc_Data(i,j), ValidVelData(i,j)] = ...
%          GPSOrbitPropagatorVelocities(GPSTime_Week(i),GPSTime_Sec(i), j, SV_Ephemeris);
%     end
%     
%     if(mod(i,1000) == 0)
%         disp(sprintf('Completed Epoch %d',i));
%     end
% end



%% arrange pseudorange measurements

PR_Sim = Novatel_C1';
PRR_Sim = -Novatel_D1' * L1_Wavelength;
CP_Sim = Novatel_L1';

% position
[InitialPosition(1),InitialPosition(2),InitialPosition(3)] = ECEF2LLH(ApproxPos);

Tecef2ned = T_ECEF2NED(InitialPosition(1),InitialPosition(2));

% velocity
InitialVelocity = [0 0 0]';  % NED velocities in m/s

% get the initial meridian and prime radii of curvature
RM = MeridianRadius(InitialPosition(2));
RP = PrimeRadius(InitialPosition(2));

% 3 position, 3 velocity, 3 accel, 3 jerk and 2 clock
NumberStates = 14;

% process noise states - 8
ProcessNoiseStates = 14;  

MaxSVs = 6;

% use a maximum of 6 measurements (PR+PRR)
MeasurementNoiseStates=2*MaxSVs;


Na = NumberStates+ProcessNoiseStates+MeasurementNoiseStates;
Na_Sub = Na-2;

% UKF scaling parameters
alpha = 0.1; % range: 1e-3 < alpha <= 1
beta = 2;  % 2 is optimal for gaussian priors
kapa = 0;  %

LAMBDA = alpha^2 * (Na+kapa) - Na;

TimeGPS = [0:gps_dt:NumberEpochsGPS-1];

%% initialise covariances
Px_kminus = eye(NumberStates,NumberStates);
Px_kminus(1:3,1:3) = eye(3,3)*5000^2;
Px_kminus(4:6,4:6) = eye(3,3)*100^2;
Px_kminus(7,7) = 100^2;
Px_kminus(8,8) = 10^2;
Px_kminus(9:11,9:11) = eye(3,3)*10^2;


GPS_PR_UERE = 3.0;
GPS_PRR_UERE = 0.1;

R = eye(MeasurementNoiseStates,MeasurementNoiseStates);
R(1:MaxSVs,1:MaxSVs) = eye(MaxSVs,MaxSVs)*GPS_PR_UERE^2;
R(MaxSVs+1:2*MaxSVs,MaxSVs+1:2*MaxSVs) = eye(MaxSVs,MaxSVs)*GPS_PRR_UERE^2;


x_hat_kminus = zeros(NumberStates,1);
%x_hat_kminus(1:3,1) = ApproxPos;
%x_hat_kminus(7,1) = 12;
GRASOn = 0;


x_hat_kminus(1:3,1) = [ -5046780.28152946          2568450.53282855         -2925294.35054563 ]';
x_hat_kminus(7,1) = 12.9024664188715;

SV_Azimuth = zeros(NumberEpochsGPS,NumberSVs);
SV_Elevation =  zeros(NumberEpochsGPS,NumberSVs);


%SVDontUse(25) = 1;
%SVDontUse(16) = 1;
%SVDontUse(20) = 1;

URALimit = 1;

%% loop through and check for SV unhealthy (Ephemeris param 27)
for i=1:size(SV_Ephemeris,1)
   
   % check for unhealthy flag 
   if(SV_Ephemeris(i,27) ~= 0)
       disp(sprintf('SV %d Ephemeris Unhealthy',SV_Ephemeris(i,1)));
      SVDontUse(SV_Ephemeris(i,1)) = 1;
   end
   
   % check for large URA
   
   if(SV_Ephemeris(i,26) > URALimit)
       disp(sprintf('SV %d URA Exceeds Limit (%d)',SV_Ephemeris(i,1),URALimit));
      SVDontUse(SV_Ephemeris(i,1)) = 1;
   end
   
end



%% values for RAIM FDE

% PFalseAlarm = 2.22e-8;
% a =  [31.2919346425215; ...
%           35.2463471007126; ...
%           38.4953686364599; ...
%           41.4010185618922; ...
%            44.090770631714; ...
%           46.6276102566246; ...
%           49.0483514687134; ...
%           51.3768201044926; ...
%           53.6295337202138; ...
%           55.8185260702011; ...
%           57.9529000257331; ...
%           60.0397472340809; ...
%           62.0847253044164; ...
%            64.092436838505; ...
%            66.066688033301; ...
%            68.010670670063; ...
%           69.9270936151405; ...
%           71.8182800246577; ...
%           73.6862406187531; ...
%           75.5327299572836];
% 
% lambdatrue = [75.4140000000001; ...
%           80.2599999999999; ...
%           83.9499999999999; ...
%           87.0779999999999; ...
%           89.8469999999999; ...
%           92.3639999999999; ...
%           94.6879999999999; ...
%           96.8589999999999; ...
%                     98.906; ...
%                    100.848; ...
%                    102.698; ...
%                    104.468; ...
%                     106.17; ...
%                     107.81; ...
%                    109.396; ...
%                     110.93; ...
%                     112.42; ...
%                    113.865; ...
%                    115.275; ...
%                    116.647];


PFalseAlarm = 2e-5;
PMissedDetection = 0.047;

a =   [         18.189293484087;...
          21.6395565688235;...
          24.4623581112611;...
          26.9869539367368;...
          29.3272057089061;...
          31.5385558129051];

lambdatrue = [35.3000000000002;...
          38.9000000000003;...
          41.6000000000003;...
          43.8000000000004;...
          45.7000000000004;...
          47.5000000000004];
               
               
               
               
               
%% parameters for EKF

% power spectral densitites of the process noise - 
% Sp - position error
% Sf - clock bias error
% Sg - clock drift error

Sp = 10;  %% dynamic receiver
Sf = 2*2e-16*Speedoflight^2;
Sg = 8*pi^2*2e-17*Speedoflight^2;
% Sf = 10;
% Sg = 1;

EKF_NumberStates = NumberStates;
% setup state transition - time invariant if dt is constant
EKF_phi = eye(EKF_NumberStates,EKF_NumberStates);

% velocity to position
EKF_phi(1,5) = gps_dt;
EKF_phi(2,6) = gps_dt;
EKF_phi(3,7) = gps_dt;

% clock drift to clock bias
EKF_phi(4,8) = gps_dt;

% acceleration to position
EKF_phi(1,9) = (gps_dt^2)/2;
EKF_phi(2,10) = (gps_dt^2)/2;
EKF_phi(3,11) = (gps_dt^2)/2;

% jerk to position
EKF_phi(1,12) = (gps_dt^3)/3;
EKF_phi(2,13) = (gps_dt^3)/3;
EKF_phi(3,14) = (gps_dt^3)/3;

% acceleration to velocity
EKF_phi(5,9) = gps_dt;
EKF_phi(6,10) = gps_dt;
EKF_phi(7,11) = gps_dt;

% jerk to velocity
EKF_phi(5,12) = (gps_dt^2)/2;
EKF_phi(6,13) = (gps_dt^2)/2;
EKF_phi(7,14) = (gps_dt^2)/2;

% jerk to acceleration
EKF_phi(9,12) = gps_dt;
EKF_phi(10,13) = gps_dt;
EKF_phi(11,14) = gps_dt;


% setup Q and R matrices (process and noise covariance)
EKF_Q = zeros(EKF_NumberStates,EKF_NumberStates);

Sp_dt5 = Sp * (gps_dt ^ 5) / 5;
Sp_dt4 = Sp * (gps_dt ^ 4) / 4;
Sp_dt3 = Sp * (gps_dt ^ 3) / 3;
Sp_dt2 = Sp * (gps_dt ^ 2) / 2;
Sp_dt = Sp * gps_dt;
Sf_dt = Sf * gps_dt;
Sg_dt3 = Sg * (gps_dt ^ 3) / 3;
Sg_dt2 = Sg * (gps_dt ^ 2) / 2;
Sg_dt = Sg * gps_dt;

EKF_Q(1,1) = Sp_dt4;
EKF_Q(2,2) = Sp_dt4;
EKF_Q(3,3) = Sp_dt4;

%EKF_Q(1,5) = Sp_dt2;
%EKF_Q(2,6) = Sp_dt2;
%EKF_Q(3,7) = Sp_dt2;
%EKF_Q(5,1) = Sp_dt2;
%EKF_Q(6,2) = Sp_dt2;
%EKF_Q(7,3) = Sp_dt2;

% clock states
EKF_Q(4,8) = Sg_dt2;
EKF_Q(8,4) = Sg_dt2;
EKF_Q(4,4) = Sf_dt + Sg_dt3;
EKF_Q(8,8) = Sg_dt;

% velocity
EKF_Q(5,5) = Sp_dt3;
EKF_Q(6,6) = Sp_dt3;
EKF_Q(7,7) = Sp_dt3;

% acceleration
EKF_Q(9,9) = Sp_dt2;
EKF_Q(10,10) = Sp_dt2;
EKF_Q(11,11) = Sp_dt2;

EKF_Q(12,12) = Sp_dt;
EKF_Q(13,13) = Sp_dt;
EKF_Q(14,14) = Sp_dt;


EKF_R = R;
SubSVs = MaxSVs-1;
    EKF_R_Sub = eye(MeasurementNoiseStates-2,MeasurementNoiseStates-2);
    EKF_R_Sub(1:SubSVs,1:SubSVs) = eye(SubSVs,SubSVs)*GPS_PR_UERE^2;
    EKF_R_Sub(SubSVs+1:2*SubSVs,SubSVs+1:2*SubSVs) = eye(SubSVs,SubSVs)*GPS_PRR_UERE^2;
    
    
UKF_R_Sub = EKF_R_Sub;

    
EKF_x_hat_kplus = x_hat_kminus(1:NumberStates);
EKF_Px_kplus = eye(EKF_NumberStates,EKF_NumberStates);
EKF_Px_kplus(1:3,1:3) = eye(3,3)*1000^2;
EKF_Px_kplus(5:7,5:7) = eye(3,3)*100^2;
EKF_Px_kplus(4,4) = 100^2;
EKF_Px_kplus(8,8) = 10^2;
               



% UKF_Q = zeros(ProcessNoiseStates,ProcessNoiseStates);
% UKF_Q(1,1) = Sp_dt3;
% UKF_Q(2,2) = Sp_dt3;
% UKF_Q(3,3) = Sp_dt3;
% UKF_Q(4,4) = Sp_dt;
% UKF_Q(5,5) = Sp_dt;
% UKF_Q(6,6) = Sp_dt;
% 
% UKF_Q(1,4) = Sp_dt2;
% UKF_Q(2,5) = Sp_dt2;
% UKF_Q(3,6) = Sp_dt2;
% 
% UKF_Q(4,1) = Sp_dt2;
% UKF_Q(5,2) = Sp_dt2;
% UKF_Q(6,3) = Sp_dt2;
% 
% UKF_Q(8,7) = Sg_dt2;
% UKF_Q(7,8) = Sg_dt2;
% 
% UKF_Q(7,7) = Sf_dt + Sg_dt3;
% UKF_Q(8,8) = Sg_dt;
% UKF_Q(9,9) = 10;
% UKF_Q(10,10) = 10;
% UKF_Q(11,11) = 10;
% UKF_Q(12,12) = 10;
% UKF_Q(13,13) = 10;
% UKF_Q(14,14) = 10;


UKF_Q = zeros(ProcessNoiseStates,ProcessNoiseStates);

UKF_Q(1,1) = Sp_dt4;
UKF_Q(2,2) = Sp_dt4;
UKF_Q(3,3) = Sp_dt4;


UKF_Q(4,4) = Sp_dt3;
UKF_Q(5,5) = Sp_dt3;
UKF_Q(6,6) = Sp_dt3;

% UKF_Q(1,4) = Sp_dt2;
% UKF_Q(2,5) = Sp_dt2;
% UKF_Q(3,6) = Sp_dt2;
% 
% UKF_Q(4,1) = Sp_dt2;
% UKF_Q(5,2) = Sp_dt2;
% UKF_Q(6,3) = Sp_dt2;

UKF_Q(8,7) = Sg_dt2;
UKF_Q(7,8) = Sg_dt2;

UKF_Q(7,7) = Sf_dt + Sg_dt3;
UKF_Q(8,8) = Sg_dt;

UKF_Q(9,9) = Sp_dt2;
UKF_Q(10,10) = Sp_dt2;
UKF_Q(11,11) = Sp_dt2;

UKF_Q(12,12) = Sp_dt;
UKF_Q(13,13) = Sp_dt;
UKF_Q(14,14) = Sp_dt;

%UKF_Q = EKF_Q;


EKF_x_hat_kminus = EKF_x_hat_kplus;
EKF_Px_kminus = EKF_Px_kplus;

StartTime = 20;
EndTime = NumberEpochsGPS;



x_sigma_points = zeros(NumberEpochsGPS,2*Na+1);
y_sigma_points = zeros(NumberEpochsGPS,2*Na+1);
z_sigma_points = zeros(NumberEpochsGPS,2*Na+1);
xdot_sigma_points = zeros(NumberEpochsGPS,2*Na+1);
ydot_sigma_points = zeros(NumberEpochsGPS,2*Na+1);
zdot_sigma_points = zeros(NumberEpochsGPS,2*Na+1);


truth_dt = 0.01;

firstLoop = 1;


% generate an error function
PR_Error = zeros(NumberEpochsGPS,1);
Error_SV = 15; % prn of satellite to add the error to
Error_rate = 0.5; % error rate in m/s
Error_start_time = 500; % start time of error in seconds
for Epoch_lo=Error_start_time:length(PR_Error)
   PR_Error(Epoch_lo) = Error_rate * (Epoch_lo-Error_start_time); 
end


%% start gps solutions
for Epoch_lo = StartTime:EndTime

    % get the gps time - used for the iono correction
    %GPSTime  = 259199 + Epoch_lo;
    GPSTime = GPSTime_Sec(Epoch_lo);
    
    % find the index of the truth data for this time step
    TruthIndex = (Epoch_lo+TruthOffset-1)/truth_dt + 1;
    
    if Epoch_lo > StartTime+30
         % reset UKF state covariance
%         UKF_Q(1,1) = 0.1;
%         UKF_Q(2,2) = 0.1;
%         UKF_Q(3,3) = 0.1;
% 
% 
%         UKF_Q(4,4) = 0.1;
%         UKF_Q(5,5) = 0.1;
%         UKF_Q(6,6) = 0.1;

    end

    % perform state prediction
    % generate augmented state vector
    xa_hat_kminus = [x_hat_kminus;zeros(ProcessNoiseStates,1);zeros(MeasurementNoiseStates,1)];

    Pxa_kminus = [Px_kminus          zeros(NumberStates,NumberStates) zeros(NumberStates,MeasurementNoiseStates);
              zeros(ProcessNoiseStates,NumberStates) UKF_Q           zeros(ProcessNoiseStates,MeasurementNoiseStates);
              zeros(MeasurementNoiseStates,NumberStates) zeros(MeasurementNoiseStates,ProcessNoiseStates)  R];
          
          
          
          
          
    %blah = sqrt(Na+LAMBDA) * chol(Pxa_kminus);
    blah = sqrt(Na+LAMBDA) * sqrtm(Pxa_kminus);
    
    for i=0:Na
        if i==0
            xs_0 = xa_hat_kminus;
            W_0_m = LAMBDA / (Na + LAMBDA);
            W_0_c = W_0_m + (1 - alpha^2 + beta);
        else
            xs_i(:,i) = xa_hat_kminus + blah(i,:)';
            xs_i(:,i+Na) = xa_hat_kminus - blah(i,:)';
            W_i_m = 1 / (2 * (Na + LAMBDA));
            W_i_c = W_i_m;
        end
    end

    
    
    [xs_0_k,xs_i_k] = GARD_PropagateSigmaPointsGPS(Na,xs_0,xs_i,gps_dt,NumberStates,ProcessNoiseStates);
    
    
    x_sigma_points(Epoch_lo,1) = xs_0_k(1);
    x_sigma_points(Epoch_lo,2:2*Na+1) = xs_i_k(1,:);
    y_sigma_points(Epoch_lo,1) = xs_0_k(2);
    y_sigma_points(Epoch_lo,2:2*Na+1) = xs_i_k(2,:);
    z_sigma_points(Epoch_lo,1) = xs_0_k(3);
    z_sigma_points(Epoch_lo,2:2*Na+1) = xs_i_k(3,:);
    
    xdot_sigma_points(Epoch_lo,1) = xs_0_k(4);
    xdot_sigma_points(Epoch_lo,2:2*Na+1) = xs_i_k(4,:);
    ydot_sigma_points(Epoch_lo,1) = xs_0_k(5);
    ydot_sigma_points(Epoch_lo,2:2*Na+1) = xs_i_k(5,:);
    zdot_sigma_points(Epoch_lo,1) = xs_0_k(6);
    zdot_sigma_points(Epoch_lo,2:2*Na+1) = xs_i_k(6,:);
    
    
    
    
    W = eye(1,2*Na+1);
    W(1,1) = W_0_m;
    W(1,2:2*Na+1) = W_i_m;
    X = zeros(NumberStates,2*Na+1);
    X(:,1) = xs_0_k(1:NumberStates);
    X(:,2:2*Na+1) = xs_i_k(1:NumberStates,:);
    x_hat_kminus = (W*X')';

    nx = length(x_hat_kminus); nw = length(W);
    Px_kminus=((ones(nx,1)*W).*(X-x_hat_kminus*ones(1,nw)))*(X-x_hat_kminus*ones(1,nw))';
        
    % initial guess at user pos required to estimate earth rotation
    % correction
    UserPos(1:3) = [x_hat_kminus(1);x_hat_kminus(2);x_hat_kminus(3)];
 %   UserPos(4) = xs_0_k(7);
        
    % format the input measurement vectors
    SVIndex = 0;
    clear SV_Vec SVPos SVVel PR_Vec PRR_Vec PR_Vec_raw
    for SV=1:NumberSVs
        if((PR_Sim(Epoch_lo,SV) > 100) && SVDontUse(SV) == 0)  %%SV ~= ExcludeSVPRN
            % add to PR vector
            SVIndex = SVIndex + 1;

            SV_Vec(SVIndex) = SV;
            PR_Vec(SVIndex) = PR_Sim(Epoch_lo,SV);
            PRR_Vec(SVIndex) = PRR_Sim(Epoch_lo,SV);
            
            
            
            if(Epoch_lo == 1)
                PRR_Vec(SVIndex) = 0;
                %PR_csc(SVIndex) = PR_Vec(SVIndex);
            else
                if(CP_Sim(Epoch_lo-1,SV) == 0)
                    %PRR_Vec(SVIndex) = (CP_Sim(Epoch_lo+1,SV) - CP_Sim(Epoch_lo,SV));
                    %PR_csc(SVIndex) = PR_Vec(SVIndex);
                else
                    %PRR_Vec(SVIndex) = (CP_Sim(Epoch_lo,SV) - CP_Sim(Epoch_lo-1,SV));

                 %%% PERFORM CARRIER PHASE SMOOTHING of PR
                 %%% HERE


                   % alpha = gps_dt/100;
                    %P_proj = PR_prev + (L1_Wavelength/(2*pi))*(CP_Sim(Epoch_lo) - CP_Sim(Epoch_lo-1));
                    %PR_csc(SVIndex) = alpha * PR_Vec(SVIndex) + (1-alpha)*P_proj;                            

                end
            end
            % save previous value
            %PR_prev = PR_csc(SVIndex);

            % dont use the carrier smoothed code
            %PR_Vec = PR_csc;                  

            % add the error
            if (SV == Error_SV)
               PR_Vec(SVIndex) = PR_Vec(SVIndex) + PR_Error(Epoch_lo); 
            end
            
            
            

%             SVPos(SVIndex,:) = [SV_X_Data(Epoch_lo,SV) SV_Y_Data(Epoch_lo,SV) SV_Z_Data(Epoch_lo,SV) SV_T_Data(Epoch_lo,SV)*c];
%             SVVel(SVIndex,:) = [SV_Xvel_Data(Epoch_lo,SV) SV_Yvel_Data(Epoch_lo,SV) SV_Zvel_Data(Epoch_lo,SV) SV_Tvel_Data(Epoch_lo,SV)*c];
%             SVAcc(SVIndex,:) = [SV_Xacc_Data(Epoch_lo,SV) SV_Yacc_Data(Epoch_lo,SV) SV_Zacc_Data(Epoch_lo,SV) SV_Tacc_Data(Epoch_lo,SV)*c];

            [SVPos(SVIndex,1), SVPos(SVIndex,2), SVPos(SVIndex,3), SVPos(SVIndex,4), ValidPosData(Epoch_lo,SV)] = ...
               GPSOrbitPropagator(GPSTime_Week(Epoch_lo), GPSTime_Sec(Epoch_lo) - PR_Vec(SVIndex)/Speedoflight, SV, SV_Ephemeris, 7500);
           
           if ValidPosData(Epoch_lo,SV) == 0
               SVIndex = SVIndex - 1;
               continue;
           end
           
             [SVVel(SVIndex,1), SVVel(SVIndex,2), SVVel(SVIndex,3), SVVel(SVIndex,4), ...
              SVAcc(SVIndex,1), SVAcc(SVIndex,2), SVAcc(SVIndex,3), SVAcc(SVIndex,4), ValidVelData(Epoch_lo,SV)] = ...
              GPSOrbitPropagatorVelocities(GPSTime_Week(Epoch_lo),GPSTime_Sec(Epoch_lo)-PR_Vec(SVIndex)/Speedoflight, SV, SV_Ephemeris,7500);
          
          if ValidVelData(Epoch_lo,SV) == 0
              SVIndex = SVIndex - 1;
              continue;
          end
          
            SVPos(SVIndex,4) = SVPos(SVIndex,4) * Speedoflight;
            SVVel(SVIndex,4) = SVVel(SVIndex,4) * Speedoflight;
            SVAcc(SVIndex,4) = SVAcc(SVIndex,4) * Speedoflight;

            [SV_Azimuth(Epoch_lo,SV), SV_Elevation(Epoch_lo,SV)] = AzEl(UserPos(1:3), SVPos(SVIndex,1:3));
           
            % calculate the iono delay correction - single frequency user
            % model from ICD 200
            if(GRASOn == 0)
                ionodelay = ionomodel(GPSTime, UserPos(1:3), SVPos(SVIndex,1:3), ALPHA, BETA);
                PR_Vec(SVIndex) = PR_Vec(SVIndex) - ionodelay;
            end
            
            if ~exist('x_save_llh','var')
                TropoDelay(Epoch_lo,SV) =  GARD_TropoDelay(SV_Elevation(Epoch_lo,SV),InitialPosition(3));
            else    
                TropoDelay(Epoch_lo,SV) =  GARD_TropoDelay(SV_Elevation(Epoch_lo,SV),x_save_llh(Epoch_lo-1,3));
            end
            PR_Vec(SVIndex) = PR_Vec(SVIndex) - TropoDelay(Epoch_lo,SV);
            
            % calculate hte earth rotation correction as per Kayton pg 228
            % eq 5.67

            
            PR_Vec_raw(SVIndex) = PR_Vec(SVIndex);  % save a raw (uncorrected copy) of the PR vector for use in the LSQ algorithm later.
            delta_pr_omegaedot = -(OMEGAedot / Speedoflight) * (SVPos(SVIndex,1) *UserPos(2) - SVPos(SVIndex,2) * UserPos(1));
            PR_Vec(SVIndex) = PR_Vec(SVIndex) + delta_pr_omegaedot + SVPos(SVIndex,4);
            PRR_Vec(SVIndex) = PRR_Vec(SVIndex) + SVVel(SVIndex,4);


        end
    end

    if exist('PR_Vec','var')
        NumberGPSMeasurements = length(PR_Vec);
    else
        disp(sprintf('Epoch %d: No Observations'));
        continue;
    end

    NumberGPSMeasurementsAvailable(Epoch_lo) = NumberGPSMeasurements;
    
    if NumberGPSMeasurements < 6
        disp(sprintf('Epoch %d: Insufficient measurements (%d)', Epoch_lo,NumberGPSMeasurements));
        continue;
    end

    if NumberGPSMeasurements > MaxSVs
        NumberGPSMeasurements = MaxSVs;
    end
    
    
        % calculate the number of sub-filters required for single satellite
    % failture detection
    NumberSubMeasurements = NumberGPSMeasurements-1;
    NumberSubFilters = nchoosek(NumberGPSMeasurements,NumberSubMeasurements);

    % formulate the measurment vector
    y_k = [PR_Vec(1:NumberGPSMeasurements)';PRR_Vec(1:NumberGPSMeasurements)'];
    
    
    EKF_H = zeros(2*NumberGPSMeasurements,EKF_NumberStates);
    EKF_H_Sub = zeros(2*NumberSubMeasurements,EKF_NumberStates);
    
    for k = 1:NumberGPSMeasurements
        % find apriori estimate of pseudorange for each sigma point

        % zero-th sigma point

        
        % Get User position in ECEF
        UserPos(1:3) = [xs_0_k(1);xs_0_k(2);xs_0_k(3)];
        UserPos(4) = xs_0_k(7);
        UserVel(1:3) =  [xs_0_k(4);xs_0_k(5);xs_0_k(6)];
        UserVel(4) = xs_0_k(8);
        
        geo_range_to_sat = sqrt((SVPos(k,1) - UserPos(1))^2 + (SVPos(k,2) - UserPos(2))^2 + (SVPos(k,3) - UserPos(3))^2);
        geo_vel_to_sat = (SVVel(k,1) - UserVel(1))*(SVPos(k,1)-UserPos(1)) + (SVVel(k,2) - UserVel(2))*(SVPos(k,2)-UserPos(2)) + (SVVel(k,3) - UserVel(3))*(SVPos(k,3)-UserPos(3));

    %% calculate measurement predicition
        % pseudorange prediction
        PR_Vec_minus_0(k) = geo_range_to_sat + UserPos(4) + xs_0(NumberStates+ProcessNoiseStates+k);% + UserVel(4) * gps_dt;  % geometric range + c * delta_T
        %predicted relative velocity of sv and receiver
        Relative_Velocity(k) = geo_vel_to_sat/geo_range_to_sat;
        PRR_Vec_minus_0(k) = Relative_Velocity(k) + UserVel(4) + xs_0(NumberStates+ProcessNoiseStates+MeasurementNoiseStates/2+k);

        for i=1:2*Na
            % Get User position in ECEF
            UserPos(1:3) = [xs_i_k(1,i);xs_i_k(2,i);xs_i_k(3,i)];
            UserPos(4) = xs_i_k(7,i);
            UserVel(1:3) =  [xs_i_k(4,i);xs_i_k(5,i);xs_i_k(6,i)];
            UserVel(4) = xs_i_k(8,i);
            
            
            geo_range_to_sat = sqrt((SVPos(k,1) - UserPos(1))^2 + (SVPos(k,2) - UserPos(2))^2 + (SVPos(k,3) - UserPos(3))^2);
            geo_vel_to_sat = (SVVel(k,1) - UserVel(1))*(SVPos(k,1)-UserPos(1)) + (SVVel(k,2) - UserVel(2))*(SVPos(k,2)-UserPos(2)) + (SVVel(k,3) - UserVel(3))*(SVPos(k,3)-UserPos(3));

            PR_Vec_minus_i(k,i) = geo_range_to_sat + UserPos(4) + xs_i(NumberStates+ProcessNoiseStates+k,i);% + UserVel(4) * gps_dt + xs_i(NumberStates+ProcessNoiseStates+k-1,i);  % geometric range + c * delta_T

            %predicted relative velocity of sv and receiver
            Relative_Velocity(k) = geo_vel_to_sat/geo_range_to_sat;
            PRR_Vec_minus_i(k,i) = Relative_Velocity(k) + UserVel(4) + xs_i(NumberStates+ProcessNoiseStates+MeasurementNoiseStates/2+k,i);
        end % for i=1:2*Na

        % calculate EKF H-matrix
        UserPos(1:4) = EKF_x_hat_kplus(1:4) + EKF_x_hat_kplus(5:8)*gps_dt + [EKF_x_hat_kplus(9:11); 0]*(gps_dt^2)/2 + [EKF_x_hat_kplus(12:14); 0]*(gps_dt^3)/3;
        UserVel(1:4) = EKF_x_hat_kplus(5:8) + [EKF_x_hat_kplus(9:11); 0]*gps_dt + [EKF_x_hat_kplus(12:14); 0]*(gps_dt^2)/2;
        for m = 1:3
             ele(m) =  SVPos(k,m) - UserPos(m);
        end    

        r_VecCalc(k) =  norm(ele);   

        
        
        EKF_H(k,1) =  -ele(1)/r_VecCalc(k);
        EKF_H(k,2) =  -ele(2)/r_VecCalc(k);
        EKF_H(k,3) =  -ele(3)/r_VecCalc(k);
        EKF_H(k,4) = 1;   
        EKF_H(k,5) = 0;
        EKF_H(k,6) = 0;
        EKF_H(k,7) = 0;
        EKF_H(k,8) = 0;

        EKF_H(k+NumberGPSMeasurements,1) = 0;
        EKF_H(k+NumberGPSMeasurements,2) = 0;
        EKF_H(k+NumberGPSMeasurements,3) = 0;
        EKF_H(k+NumberGPSMeasurements,4) = 0;   
        EKF_H(k+NumberGPSMeasurements,5) = -ele(1)/r_VecCalc(k);
        EKF_H(k+NumberGPSMeasurements,6) = -ele(2)/r_VecCalc(k);
        EKF_H(k+NumberGPSMeasurements,7) = -ele(3)/r_VecCalc(k);
        EKF_H(k+NumberGPSMeasurements,8) = 1;

        % find apriori estimate of pseudorange
        PR_Vec_minus(k) = r_VecCalc(k) + UserPos(4);% + UserVel(4) * gps_dt;  % geometric range + c * delta_T
        %predicted relative velocity of sv and receiver
        r_VecCalcVel(k) = (SVVel(k,1) - UserVel(1))*(SVPos(k,1)-UserPos(1)) + ...
                          (SVVel(k,2) - UserVel(2))*(SVPos(k,2)-UserPos(2)) + ...
                          (SVVel(k,3) - UserVel(3))*(SVPos(k,3)-UserPos(3));
        Relative_Velocity(k) = r_VecCalcVel(k)/r_VecCalc(k);
        PRR_Vec_minus(k) = Relative_Velocity(k) + UserVel(4);
        

    end  % for k = 1:NumberGPSMeasurements

    ys_kminus_0 = [PR_Vec_minus_0'; PRR_Vec_minus_0'];
    ys_kminus_i = [PR_Vec_minus_i(:,:); PRR_Vec_minus_i(:,:)];
    
    % find the sum of sigma points for the measurement prediction
   

    W = ones(1,2*Na+1);
    W(1,1) = W_0_m;
    W(1,2:2*Na+1) = W_i_m;

    Y = zeros(MeasurementNoiseStates,2*Na+1);
    Y(:,1) = ys_kminus_0(1:MeasurementNoiseStates);
    Y(:,2:2*Na+1) = ys_kminus_i(1:MeasurementNoiseStates,:);
    y_hat_kminus = (W*Y')';

    nx = length(x_hat_kminus); ny = length(y_hat_kminus); nw = length(W);
    Py_kminus=((ones(ny,1)*W).*(Y-y_hat_kminus*ones(1,nw)))*(Y-y_hat_kminus*ones(1,nw))';
    Pxy_kminus =((ones(nx,1)*W).*(X-x_hat_kminus*ones(1,nw)))*(Y-y_hat_kminus*ones(1,nw))';

    %% Py_kminus is equivalent to HPxH'+R 
    %% Pxy_kminus PxH' 
    %% therefor Hequiv = (inv(Px_kminus)*Pxy_kminus)'
    % calculate 'H' by normalizing Pxy
    Hequiv = (inv(Px_kminus) * Pxy_kminus)';
    Hequiv2(1:NumberGPSMeasurements,1:3) = Hequiv(1:NumberGPSMeasurements,1:3);
    Hequiv2(1:NumberGPSMeasurements,4) = Hequiv(1:NumberGPSMeasurements,7);
    
    
    
    [lat,lon] = ECEF2LLH(ApproxPos);
    Tecef2ned2 = T_ECEF2NED(lat,lon);
    Tecef2ned2(4,1:3) = [0 0 0];
    Tecef2ned2(1:4,4) = [0 0 0 1];
    H_ltp = Hequiv2 * Tecef2ned2';
        
    % calculate covariance matrix (AA) and transform to local coords
    AA = inv(H_ltp' * H_ltp);
    
    % calculate DOPs
    var_x = AA(1,1);
    var_y = AA(2,2);
    var_z = AA(3,3);
    var_dt = AA(4,4);
    DOP_UKF(Epoch_lo,1) = sqrt(var_x + var_y + var_z + var_dt);     % GDOP
    DOP_UKF(Epoch_lo,2) = sqrt(var_x + var_y + var_z);              % PDOP
    DOP_UKF(Epoch_lo,3) = sqrt(var_x + var_y);                      % HDOP
    DOP_UKF(Epoch_lo,4) = sqrt(var_z);                              % VDOP
    DOP_UKF(Epoch_lo,5) = sqrt(var_dt);                             % TDOP
    
    
    % calculate kalman gain
    K_k = Pxy_kminus * inv(Py_kminus);
    %K_k = (Pxy_kminus / Sy_kminus') / Sy_kminus;

    % apply correction
    z_k = y_k - y_hat_kminus;
    z_save(Epoch_lo,:) = z_k;
    

    
    x_hat_kplus = x_hat_kminus + K_k * (z_k);

    Px_kplus = Px_kminus - K_k * Py_kminus * K_k';


    %% calculate EKF solution for comparisson
    
    
    
    %EKF_z = [PR_Vec(1:NumberGPSMeasurements)';PRR_Vec(1:NumberGPSMeasurements)'];
    EKF_z = ([PR_Vec(1:NumberGPSMeasurements) PRR_Vec(1:NumberGPSMeasurements)]' - [PR_Vec_minus(1:NumberGPSMeasurements) PRR_Vec_minus(1:NumberGPSMeasurements)]');
    
    EKF_z_save(Epoch_lo,:) = EKF_z;
    
    [EKF_x_hat_kplus, EKF_Px_kplus, EKF_v_out, EKF_s2_out] = ...
        GARD_EvaluateKF(gps_dt, EKF_x_hat_kminus, EKF_Px_kminus, ...
        EKF_phi, EKF_H, EKF_z, EKF_Q, EKF_R);
    
    
    EKF_x_hat_save(Epoch_lo,:) = EKF_x_hat_kplus;
    EKF_P_save(Epoch_lo,:) = diag(EKF_Px_kplus);
    
    EKF_x_hat_kminus = EKF_x_hat_kplus;
    EKF_Px_kminus = EKF_Px_kplus;
    
    
    % if we're on the first loop, initialise the Subfilters from the full filter
    if firstLoop == 1
        for SubSolution = 1:NumberSubFilters
    
           %% UKF
           x_hat_kminus_Sub(:,SubSolution) = x_hat_kplus;
           Px_kminus_Sub(:,:,SubSolution) = Px_kplus;
            
            
            
           %% EKF 
           EKF_x_hat_kplus_Sub(:,SubSolution) = EKF_x_hat_kminus;
           EKF_Px_kplus_Sub(:,:,SubSolution) = EKF_Px_kminus; 
           
           EKF_x_hat_kminus_Sub(:,SubSolution) = EKF_x_hat_kplus_Sub(:,SubSolution);
           EKF_Px_kminus_Sub(:,:,SubSolution) = EKF_Px_kplus_Sub(:,:,SubSolution);
            
           
        end
    end
    
    
    
    
        
        %% do the sub filter solutions
        for SubSolution = 1:NumberSubFilters
            
            
            % form the PR and CP vectors with one measurement left
            % out

            PR_SubVec(1:SubSolution-1) = PR_Vec(1:SubSolution-1);
            PR_SubVec(SubSolution:NumberSubMeasurements) = PR_Vec(SubSolution+1:NumberGPSMeasurements);

            PRR_SubVec(1:SubSolution-1) = PRR_Vec(1:SubSolution-1);
            PRR_SubVec(SubSolution:NumberSubMeasurements) = PRR_Vec(SubSolution+1:NumberGPSMeasurements);

            SVPos_Sub(1:SubSolution-1,:) = SVPos(1:SubSolution-1,:);
            SVPos_Sub(SubSolution:NumberSubMeasurements,:) = SVPos(SubSolution+1:NumberGPSMeasurements,:);

            SVVel_Sub(1:SubSolution-1,:) = SVVel(1:SubSolution-1,:);
            SVVel_Sub(SubSolution:NumberSubMeasurements,:) = SVVel(SubSolution+1:NumberGPSMeasurements,:);

                    
            % formulate the measurment vector
            y_k_Sub = [PR_SubVec(1:NumberSubMeasurements)';PRR_SubVec(1:NumberSubMeasurements)'];


            % get the sigma points for this sub-filter to work on
            [xs_Sub, Ws_Sub] = GARD_GenerateSigmaPoints(x_hat_kminus_Sub(:,SubSolution), Px_kminus_Sub(:,:,SubSolution), UKF_Q, UKF_R_Sub, alpha, beta, kapa);
            
            xs_0_Sub = xs_Sub(:,1);
            xs_i_Sub = xs_Sub(:,2:size(xs_Sub,2));
            
            % propagate the SPs
            [xs_0_k_Sub,xs_i_k_Sub] = GARD_PropagateSigmaPointsGPS(Na_Sub,xs_0_Sub,xs_i_Sub,gps_dt,NumberStates,ProcessNoiseStates);
            
            
            
            
            % generate predicted mean and covariance
            xs_k_Sub = [xs_0_k_Sub',xs_i_k_Sub];
            [x_hat_kminus_Sub(:,SubSolution),Px_kminus_Sub(:,:,SubSolution)] = GARD_GenerateMeanFromSigmaPoints(xs_k_Sub,Ws_Sub,NumberStates);
            
            for k = 1:NumberSubMeasurements
                % find apriori estimate of pseudorange for each sigma point

                % zero-th sigma point


                % Get User position in ECEF
                UserPos(1:3) = [xs_0_k_Sub(1);xs_0_k_Sub(2);xs_0_k_Sub(3)];
                UserPos(4) = xs_0_k_Sub(7);
                UserVel(1:3) =  [xs_0_k_Sub(4);xs_0_k_Sub(5);xs_0_k_Sub(6)];
                UserVel(4) = xs_0_k_Sub(8);
                
                

                geo_range_to_sat = sqrt((SVPos_Sub(k,1) - UserPos(1))^2 + (SVPos_Sub(k,2) - UserPos(2))^2 + (SVPos_Sub(k,3) - UserPos(3))^2);
                geo_vel_to_sat = (SVVel_Sub(k,1) - UserVel(1))*(SVPos_Sub(k,1)-UserPos(1)) + ...
                                 (SVVel_Sub(k,2) - UserVel(2))*(SVPos_Sub(k,2)-UserPos(2)) + ...
                                 (SVVel_Sub(k,3) - UserVel(3))*(SVPos_Sub(k,3)-UserPos(3));

            %% calculate measurement predicition
                % pseudorange prediction
                PR_Vec_minus_0_Sub(k) = geo_range_to_sat + UserPos(4) + xs_0_Sub(NumberStates+ProcessNoiseStates+k);% + UserVel(4) * gps_dt;  % geometric range + c * delta_T
                %predicted relative velocity of sv and receiver
                Relative_Velocity_Sub(k) = geo_vel_to_sat/geo_range_to_sat;
                PRR_Vec_minus_0_Sub(k) = Relative_Velocity_Sub(k) + UserVel(4) + xs_0_Sub(NumberStates+ProcessNoiseStates+((MeasurementNoiseStates-2)/2)+k);

                for i=1:2*Na_Sub
                    % Get User position in ECEF
                    UserPos(1:3) = [xs_i_k_Sub(1,i);xs_i_k_Sub(2,i);xs_i_k_Sub(3,i)];
                    UserPos(4) = xs_i_k_Sub(7,i);
                    UserVel(1:3) =  [xs_i_k_Sub(4,i);xs_i_k_Sub(5,i);xs_i_k_Sub(6,i)];
                    UserVel(4) = xs_i_k_Sub(8,i);


                    geo_range_to_sat = sqrt((SVPos_Sub(k,1) - UserPos(1))^2 + (SVPos_Sub(k,2) - UserPos(2))^2 + (SVPos_Sub(k,3) - UserPos(3))^2);
                    geo_vel_to_sat = (SVVel_Sub(k,1) - UserVel(1))*(SVPos_Sub(k,1)-UserPos(1)) + ...
                                     (SVVel_Sub(k,2) - UserVel(2))*(SVPos_Sub(k,2)-UserPos(2)) + ...
                                     (SVVel_Sub(k,3) - UserVel(3))*(SVPos_Sub(k,3)-UserPos(3));

                    PR_Vec_minus_i_Sub(k,i) = geo_range_to_sat + UserPos(4) + xs_i_Sub(NumberStates+ProcessNoiseStates+k,i);% + UserVel(4) * gps_dt + xs_i(NumberStates+ProcessNoiseStates+k-1,i);  % geometric range + c * delta_T

                    %predicted relative velocity of sv and receiver
                    Relative_Velocity_Sub(k) = geo_vel_to_sat/geo_range_to_sat;
                    PRR_Vec_minus_i_Sub(k,i) = Relative_Velocity_Sub(k) + UserVel(4) + xs_i_Sub(NumberStates+ProcessNoiseStates+((MeasurementNoiseStates-2)/2)+k,i);
                end % for i=1:2*Na

                % calculate EKF H-matrix
                %UserPos(1:4) = EKF_x_hat_kminus(1:4);
                %UserVel(1:4) = EKF_x_hat_kminus(5:8);
                %UserPos(1:4) = EKF_x_hat_kplus(1:4) + EKF_x_hat_kplus(5:8)*gps_dt + [EKF_x_hat_kplus(9:11); 0]*(gps_dt^2)/2 + [EKF_x_hat_kplus(12:14); 0]*(gps_dt^3)/3;
                %UserVel(1:4) = EKF_x_hat_kplus(5:8) + [EKF_x_hat_kplus(9:11); 0]*gps_dt + [EKF_x_hat_kplus(12:14); 0]*(gps_dt^2)/2;
                UserPos(1:4) = EKF_x_hat_kminus_Sub(1:4,SubSolution) + EKF_x_hat_kminus_Sub(5:8,SubSolution)*gps_dt + [EKF_x_hat_kminus_Sub(9:11,SubSolution); 0]*(gps_dt^2)/2 + [EKF_x_hat_kminus_Sub(12:14,SubSolution); 0]*(gps_dt^3)/3;
                UserVel(1:4) = EKF_x_hat_kminus_Sub(5:8,SubSolution) + [EKF_x_hat_kminus_Sub(9:11,SubSolution); 0]*gps_dt + [EKF_x_hat_kminus_Sub(12:14,SubSolution); 0]*(gps_dt^2)/2;



                for m = 1:3
                     ele(m) =  SVPos_Sub(k,m) - UserPos(m);
                end    

                r_VecCalc_Sub(k) =  norm(ele);   

                EKF_H_Sub(k,1) =  -ele(1)/r_VecCalc_Sub(k);
                EKF_H_Sub(k,2) =  -ele(2)/r_VecCalc_Sub(k);
                EKF_H_Sub(k,3) =  -ele(3)/r_VecCalc_Sub(k);
                EKF_H_Sub(k,4) = 1;   
                EKF_H_Sub(k,5) = 0;
                EKF_H_Sub(k,6) = 0;
                EKF_H_Sub(k,7) = 0;
                EKF_H_Sub(k,8) = 0;

                EKF_H_Sub(k+NumberSubMeasurements,1) = 0;
                EKF_H_Sub(k+NumberSubMeasurements,2) = 0;
                EKF_H_Sub(k+NumberSubMeasurements,3) = 0;
                EKF_H_Sub(k+NumberSubMeasurements,4) = 0;   
                EKF_H_Sub(k+NumberSubMeasurements,5) = -ele(1)/r_VecCalc_Sub(k);
                EKF_H_Sub(k+NumberSubMeasurements,6) = -ele(2)/r_VecCalc_Sub(k);
                EKF_H_Sub(k+NumberSubMeasurements,7) = -ele(3)/r_VecCalc_Sub(k);
                EKF_H_Sub(k+NumberSubMeasurements,8) = 1;

                % find apriori estimate of pseudorange
                PR_Vec_minus_Sub(k) = r_VecCalc_Sub(k) + UserPos(4);% + UserVel(4) * gps_dt;  % geometric range + c * delta_T
                %predicted relative velocity of sv and receiver
                r_VecCalcVel_Sub(k) = (SVVel_Sub(k,1) - UserVel(1))*(SVPos_Sub(k,1)-UserPos(1)) + ...
                                      (SVVel_Sub(k,2) - UserVel(2))*(SVPos_Sub(k,2)-UserPos(2)) + ...
                                      (SVVel_Sub(k,3) - UserVel(3))*(SVPos_Sub(k,3)-UserPos(3));
                Relative_Velocity_Sub(k) = r_VecCalcVel_Sub(k)/r_VecCalc_Sub(k);
                PRR_Vec_minus_Sub(k) = Relative_Velocity_Sub(k) + UserVel(4);


            end  % for k = 1:NumberGPSMeasurements


            SV_Used(Epoch_lo,:) = SV_Vec(1:NumberGPSMeasurements);
            SV_Visible(Epoch_lo,1:length(PR_Vec)) = SV_Vec;

            ys_kminus_0_Sub = [PR_Vec_minus_0_Sub'; PRR_Vec_minus_0_Sub'];
            ys_kminus_i_Sub = [PR_Vec_minus_i_Sub(:,:); PRR_Vec_minus_i_Sub(:,:)];

            % find the sum of sigma points for the measurement prediction
            ys_Sub = [ys_kminus_0_Sub,ys_kminus_i_Sub];
            [y_hat_kminus_Sub,Py_kminus_Sub,Pxy_kminus_Sub] = GARD_GenerateMeasurementMeanFromSigmaPoints(xs_k_Sub,ys_Sub,Ws_Sub,NumberStates,NumberSubMeasurements);


            % calculate kalman gain
            K_k_Sub = Pxy_kminus_Sub * inv(Py_kminus_Sub);
            %K_k = (Pxy_kminus / Sy_kminus') / Sy_kminus;

            % apply correction
            z_k_Sub = y_k_Sub - y_hat_kminus_Sub;
            %z_save_Sub(Epoch_lo,:) = z_k;



            x_hat_kplus_Sub(:,SubSolution) = x_hat_kminus_Sub(:,SubSolution) + K_k_Sub * (z_k_Sub);
            Px_kplus_Sub(:,:,SubSolution) = Px_kminus_Sub(:,:,SubSolution) - K_k_Sub * Py_kminus_Sub * K_k_Sub';

            % update for input of next epoch
            x_hat_kminus_Sub(:,SubSolution) = x_hat_kplus_Sub(:,SubSolution);
            Px_kminus_Sub(:,:,SubSolution) = Px_kplus_Sub(:,:,SubSolution);
            
            
 
            % DO EKF solution
            EKF_z_Sub = ([PR_SubVec(1:NumberGPSMeasurements-1) PRR_SubVec(1:NumberGPSMeasurements-1)]' - ...
                [PR_Vec_minus_Sub(1:NumberGPSMeasurements-1) PRR_Vec_minus_Sub(1:NumberGPSMeasurements-1)]');

            [EKF_x_hat_kplus_Sub(:,SubSolution), EKF_Px_kplus_Sub(:,:,SubSolution), EKF_v_out_Sub, EKF_s2_out_Sub] = ...
            GARD_EvaluateKF(gps_dt, EKF_x_hat_kminus_Sub(:,SubSolution), EKF_Px_kminus_Sub(:,:,SubSolution), ...
            EKF_phi, EKF_H_Sub, EKF_z_Sub, EKF_Q, EKF_R_Sub);
            
        
            
        
            % output of this step becomes input for next step
            EKF_x_hat_kminus_Sub(:,SubSolution) = EKF_x_hat_kplus_Sub(:,SubSolution);
            EKF_Px_kminus_Sub(:,:,SubSolution) = EKF_Px_kplus_Sub(:,:,SubSolution);
    

        end %% sub solutions

        
        % save the subsolutions result
        EKF_x_hat_save_sub(Epoch_lo,:,:) = EKF_x_hat_kminus_Sub;
        UKF_x_hat_save_sub(Epoch_lo,:,:) = x_hat_kminus_Sub;
        
        % form the solution separation vectors
        for j = 1:NumberSubFilters
            % note that only the position estimates are used - not
            % clock or velocity
            P_ned = abs(Tecef2ned * Px_kplus(1:3,1:3));
            P_ned_Sub = abs(Tecef2ned * Px_kplus_Sub(1:3,1:3,j));

            NED_ss = Tecef2ned * (x_hat_kplus(1:3) - x_hat_kplus_Sub(1:3,j));
            UKF_Beta_ss(:,j) = NED_ss(1:2);
            UKF_B_ss(:,:,j) = abs(P_ned_Sub(1:2,1:2) - P_ned(1:2,1:2));

            %UKF_lambda_ss(Epoch_lo,j) = UKF_Beta_ss(:,j)' * pinv(UKF_B_ss(:,:,j)) * UKF_Beta_ss(:,j);
            UKF_lambda_ss(Epoch_lo,j) = UKF_Beta_ss(:,j)' * UKF_Beta_ss(:,j);

            UKF_B_lambda = eigs(UKF_B_ss(:,:,j));
            UKF_TD_H(Epoch_lo,j) = sqrt(max(UKF_B_lambda)) * abs(norminv(PFalseAlarm/NumberGPSMeasurements,0,1));

            if(UKF_lambda_ss(Epoch_lo,j) > UKF_TD_H(Epoch_lo,j))
                disp(sprintf('[UKF] H-Fault detected at Epoch %d on Sub-filter %d (PRN%d)',Epoch_lo,j,SV_Vec(j)));
                UKF_FaultDetected_H(Epoch_lo,j) = SV_Vec(j);
                UKF_RAIM_ALERT_H(Epoch_lo) = 100;
            end

            %UKF_PPL_sub(Epoch_lo,j) = sqrt(Px_kplus_Sub(1,1,j)^2 + Px_kplus_Sub(2,2,j)^2 + Px_kplus_Sub(3,3,j)^2) + TD(Epoch_lo,j);

            UKF_Beta_ss_V(:,j) = NED_ss(3);
            UKF_B_ss_V(:,:,j) = P_ned_Sub(3,3) - P_ned(3,3);

            UKF_lambda_ss_V(Epoch_lo,j) = UKF_Beta_ss_V(:,j)' * pinv(UKF_B_ss_V(:,:,j)) * UKF_Beta_ss_V(:,j);

            UKF_B_lambda_V = eigs(UKF_B_ss_V(:,:,j));
            UKF_TD_V(Epoch_lo,j) = sqrt(max(UKF_B_lambda_V)) * abs(norminv(PFalseAlarm/NumberGPSMeasurements,0,1));

            if(UKF_lambda_ss_V(Epoch_lo,j) > UKF_TD_V(Epoch_lo,j))
                disp(sprintf('[UKF] V-Fault detected at Epoch %d on Sub-filter %d (PRN%d)',Epoch_lo,j,SV_Vec(j)));
                UKF_FaultDetected_V(Epoch_lo,j) = SV_Vec(j);
                UKF_RAIM_ALERT_V(Epoch_lo) = 100;
            end

            %% this HPL represents the fault-free (H0) hypothesis. 
            Sigma_MD_H = abs(norminv(PMissedDetection,0,1));
            Sigma_MD_V = abs(norminv(PMissedDetection,0,1));
            UKF_HPL_sub(Epoch_lo,j) = Sigma_MD_H * sqrt(P_ned(1,1)^2 + P_ned(2,2)^2) + UKF_TD_H(Epoch_lo,j);
            UKF_VPL_sub(Epoch_lo,j) = Sigma_MD_V * sqrt(P_ned(3,3)^2) + UKF_TD_V(Epoch_lo,j);

            %% todo - calculate the Fault-in progress (h1) hypothesis based
            %% HPL_H1.



            EKF_x_ned = Tecef2ned * EKF_x_hat_kplus(1:3);
            EKF_x_ned_Sub = Tecef2ned * EKF_x_hat_kplus_Sub(1:3,j);
            EKF_P_ned = Tecef2ned * EKF_Px_kplus(1:3,1:3);
            EKF_P_ned_Sub = Tecef2ned * EKF_Px_kplus_Sub(1:3,1:3,j);

            
            EKF_Beta_ss(:,j) = EKF_x_ned(1:2) - EKF_x_ned_Sub(1:2);
            EKF_B_ss(:,:,j) = abs(EKF_P_ned(1:2,1:2) - EKF_P_ned_Sub(1:2,1:2));

            %EKF_lamda_ss(j) = EKF_Beta_ss(:,j)' * pinv(EKF_B_ss(:,:,j)) * EKF_Beta_ss(:,j);
            EKF_lambda_ss(Epoch_lo,j) = EKF_Beta_ss(:,j)' * EKF_Beta_ss(:,j);

            EKF_B_lambda = eigs(EKF_B_ss(:,:,j));
            EKF_TD_H(Epoch_lo,j) = sqrt(max(EKF_B_lambda)) * abs(norminv(PFalseAlarm/NumberSubMeasurements,0,1));

            if(EKF_lambda_ss(Epoch_lo,j) > EKF_TD_H(Epoch_lo,j))
                disp(sprintf('[EKF] H-Fault detected at Epoch %d on Sub-filter %d (PRN%d)',Epoch_lo,j,SV_Vec(j)));
                EKF_FaultDetected_H(Epoch_lo,j) = SV_Vec(j);
                EKF_RAIM_ALERT_H(Epoch_lo) = 100;
            end
            
            %EKF_PPL_sub(Epoch_lo,j) = sqrt(EKF_Px_kplus_Sub(1,1,j)^2 + EKF_Px_kplus_Sub(2,2,j)^2 + EKF_Px_kplus_Sub(3,3,j)^2) + EKF_TD_H(Epoch_lo,j);
            EKF_Beta_ss_V(:,j) = EKF_x_ned(3) - EKF_x_ned_Sub(3);
            EKF_B_ss_V(:,:,j) = abs(EKF_P_ned(3,3) - EKF_P_ned_Sub(3,3));

            EKF_lambda_ss_V(Epoch_lo,j) = EKF_Beta_ss_V(:,j)' * EKF_Beta_ss_V(:,j);

            EKF_B_lambda_V = eigs(EKF_B_ss_V(:,:,j));
            EKF_TD_V(Epoch_lo,j) = sqrt(max(EKF_B_lambda_V)) * abs(norminv(PFalseAlarm/NumberSubMeasurements,0,1));

            if(EKF_lambda_ss_V(Epoch_lo,j) > EKF_TD_V(Epoch_lo,j))
                disp(sprintf('[EKF] V-Fault detected at Epoch %d on Sub-filter %d (PRN%d)',Epoch_lo,j,SV_Vec(j)));
                EKF_FaultDetected_V(Epoch_lo,j) = SV_Vec(j);
                EKF_RAIM_ALERT_V(Epoch_lo) = 100;
            end
            
            EKF_HPL_sub(Epoch_lo,j) = sqrt(EKF_P_ned(1,1)^2 + EKF_P_ned(2,2)^2) + EKF_TD_H(Epoch_lo,j);
            EKF_VPL_sub(Epoch_lo,j) = sqrt(EKF_P_ned(3,3)^2) + EKF_TD_V(Epoch_lo,j);

         

        end
%        UKF_PPL(Epoch_lo) = max(UKF_PPL_sub(Epoch_lo,:));
        UKF_HPL(Epoch_lo) = max(UKF_HPL_sub(Epoch_lo,:));
        UKF_VPL(Epoch_lo) = max(UKF_VPL_sub(Epoch_lo,:));
        
%        EKF_PPL(Epoch_lo) = max(EKF_PPL_sub(Epoch_lo,:));
        EKF_HPL(Epoch_lo) = max(EKF_HPL_sub(Epoch_lo,:));
        EKF_VPL(Epoch_lo) = max(EKF_VPL_sub(Epoch_lo,:));
           
        
    %% calculate solution using least squares for comparisson
    [LSQ_Solution(Epoch_lo,:), LSQ_Variance(Epoch_lo,:), LSQ_NumIterations(Epoch_lo), ...
        LSQ_ResidualVector(Epoch_lo,:), LSQ_M, LSQ_Fail(Epoch_lo), ...
        LSQ_limit(Epoch_lo), LSQ_DOP(Epoch_lo,:)] = GARD_LSQ([ApproxPos 0],NumberGPSMeasurements, PR_Vec_raw(1:NumberGPSMeasurements),SVPos(1:NumberGPSMeasurements,:));
    
   %% do RAIM Parity on LSQ solution - Note, you must run
   %% GARDSim_CalculateThresholdPbias before using this.
   [LSQ_BadGeometry(Epoch_lo), LSQ_RAIM_ALERT(Epoch_lo), LSQ_SLOPE_Max(Epoch_lo), LSQ_r(Epoch_lo), LSQ_Td(Epoch_lo), ...
       LSQ_RAIM_HPL(Epoch_lo),LSQ_RAIM_VPL(Epoch_lo), LSQ_FaultySatFDI(Epoch_lo)] = ...
       GARDSim_RAIMParity(a, lambdatrue, NumberGPSMeasurements,PFalseAlarm,GPS_PR_UERE,556,LSQ_ResidualVector(Epoch_lo,:)',LSQ_M*Tecef2ned2');
       
    
    LSQ_SSE(Epoch_lo) = LSQ_ResidualVector(Epoch_lo,:)*LSQ_ResidualVector(Epoch_lo,:)';
    
   if(LSQ_RAIM_ALERT(Epoch_lo))
      disp(sprintf('RAIM Error Detected at epoch %d',Epoch_lo)); 
   end
    
    
    
    %save results
    t_save(Epoch_lo) = Epoch_lo;
    x_hat_save(Epoch_lo,:) = x_hat_kplus;
    P_save(Epoch_lo,:) = diag(Px_kplus);


    % copy updated state to high-speed loop state for next round
    x_hat_kminus = x_hat_kplus;
    Px_kminus = Px_kplus;
    
    
        
    %% convert results to LLH
    [x_save_llh(Epoch_lo,1),x_save_llh(Epoch_lo,2),x_save_llh(Epoch_lo,3)] = ECEF2LLH(x_hat_save(Epoch_lo,1:3));
    [EKF_x_save_llh(Epoch_lo,1),EKF_x_save_llh(Epoch_lo,2),EKF_x_save_llh(Epoch_lo,3)] = ECEF2LLH(EKF_x_hat_save(Epoch_lo,1:3));
    [LSQ_x_save_llh(Epoch_lo,1),LSQ_x_save_llh(Epoch_lo,2),LSQ_x_save_llh(Epoch_lo,3)] = ECEF2LLH(LSQ_Solution(Epoch_lo,1:3));
    
    Tecef2ned = T_ECEF2NED(x_save_llh(Epoch_lo,1),x_save_llh(Epoch_lo,2));
    

    P_save_NED(Epoch_lo,1:3) = abs(Tecef2ned*P_save(Epoch_lo,1:3)');
    S_save_NED(Epoch_lo,1:3) = sqrt(P_save_NED(Epoch_lo,1:3));

    EKF_P_save_NED(Epoch_lo,1:3) = abs(Tecef2ned*EKF_P_save(Epoch_lo,1:3)');
    EKF_S_save_NED(Epoch_lo,1:3) = sqrt(EKF_P_save_NED(Epoch_lo,1:3));
    
    EKF_P_save_NED(Epoch_lo,1:3) = abs(Tecef2ned*EKF_P_save(Epoch_lo,1:3)');
    EKF_S_save_NED(Epoch_lo,1:3) = sqrt(EKF_P_save_NED(Epoch_lo,1:3));
    
    %% calculate velocity in North-East-Down

    x_save_vel(Epoch_lo,:) = Tecef2ned*x_hat_save(Epoch_lo,4:6)';
    P_save_vel(Epoch_lo,:) = abs(Tecef2ned*P_save(Epoch_lo,4:6)');
    S_save_vel(Epoch_lo,:) = sqrt(P_save_vel(Epoch_lo,1:3));
    
    
    %% calculate acceleration in North-East-Down

    x_save_acc(Epoch_lo,:) = Tecef2ned*x_hat_save(Epoch_lo,9:11)';
    P_save_acc(Epoch_lo,:) = abs(Tecef2ned*P_save(Epoch_lo,9:11)');
    S_save_acc(Epoch_lo,:) = sqrt(P_save_acc(Epoch_lo,1:3));
    
    %% calculate position error
%    ECEFError_UKF(Epoch_lo,:) = x_hat_save(Epoch_lo,1:3) - sim_truth(TruthOffset+Epoch_lo-1,2:4);
%    ECEFError_LSQ(Epoch_lo,:) = LSQ_Solution(Epoch_lo,1:3) - sim_truth(TruthOffset+Epoch_lo-1,2:4);
%    ECEFError_EKF(Epoch_lo,:) = EKF_x_hat_save(Epoch_lo,1:3) - sim_truth(TruthOffset+Epoch_lo-1,2:4);

    ECEFError_UKF(Epoch_lo,:) = x_hat_save(Epoch_lo,1:3) - pos_truth_ecef(2:4,TruthIndex)';
    ECEFError_LSQ(Epoch_lo,:) = LSQ_Solution(Epoch_lo,1:3) - pos_truth_ecef(2:4,TruthIndex)';
    ECEFError_EKF(Epoch_lo,:) = EKF_x_hat_save(Epoch_lo,1:3) - pos_truth_ecef(2:4,TruthIndex)';

    %% calculate velocity in North-East-Down
    lat = pos_truth_llh(2,TruthIndex);
    lon = pos_truth_llh(3,TruthIndex);
    Tecef2ned = T_ECEF2NED(lat,lon);
    
    NEDError_UKF(Epoch_lo,:) = Tecef2ned * ECEFError_UKF(Epoch_lo,:)';
    NEDError_LSQ(Epoch_lo,:) = Tecef2ned * ECEFError_LSQ(Epoch_lo,:)';
    NEDError_EKF(Epoch_lo,:) = Tecef2ned * ECEFError_EKF(Epoch_lo,:)';
    
%     pos_error_llh(Epoch_lo,:) = x_save_llh(Epoch_lo,:) - pos_truth_llh(2:4,Epoch_lo*100)';
%     pos_error_llh(Epoch_lo,1) = pos_error_llh(Epoch_lo,1) * RM;
%     pos_error_llh(Epoch_lo,2) = pos_error_llh(Epoch_lo,2) * RP * cos(pos_truth_llh(2,Epoch_lo*100));
    
    
%     vel_error_ned(Epoch_lo,:) = x_save_vel(Epoch_lo,:) - vel_truth(2:4,Epoch_lo*100)';

%% uncomment the below line if hte 11-state filter is used.
%    x_save_acc(Epoch_lo,:) = Tecef2ned*x_hat_save(Epoch_lo,9:11)';
    
    %% update R-matrix
%     if(Epoch_lo > 10)
%         for k = 1:NumberGPSMeasurements
%             R(k,k) = std(abs(z_save(:,k)))^2;
%             R(k+NumberGPSMeasurements,k+NumberGPSMeasurements) = std(abs(z_save(:,k+NumberGPSMeasurements)))^2;
%         end
%     end
%     
    
    
    
    
    disp(sprintf('Completed Epoch %d',Epoch_lo));
    firstLoop = 0;
    
    
    
end




%% calculate pseudo-attitude - x_save_acc x_save_vel
for(index = StartTime:EndTime)
%    [pseudo_roll(index),gps_flight_path_angle(index),gps_track(index)] = GARD_PseudoAttitude(x_save_vel(index,:),x_save_acc(index,:));
end

%roll_error = -pseudo_roll - sim_truth(39:length(sim_truth),19)';
%pitch_error = gps_flight_path_angle - sim_truth(39:length(sim_truth),18)';

%figure();
%plot(roll_error*180/pi);
%figure();
%plot(pitch_error*180/pi);

%% plot results
% figure();
% plot3(x_hat_save(:,1),x_hat_save(:,2),x_hat_save(:,3));

% figure(); hold on;
% plot(x_save_llh(:,2)*180/pi,x_save_llh(:,1)*180/pi,'b-');
% plot(EKF_x_save_llh(:,2)*180/pi,EKF_x_save_llh(:,1)*180/pi,'g-');
% plot(LSQ_x_save_llh(:,2)*180/pi,LSQ_x_save_llh(:,1)*180/pi,'r*');
% xlabel('Longitude (deg)');
% ylabel('Latitude (deg)');
% grid on;
% title('GPS UKF Position Solution');
% 
figure(); hold on;
plot3(x_save_llh(StartTime:EndTime,2)*180/pi,x_save_llh(StartTime:EndTime,1)*180/pi,x_save_llh(StartTime:EndTime,3),'b-');
plot3(EKF_x_save_llh(StartTime:EndTime,2)*180/pi,EKF_x_save_llh(StartTime:EndTime,1)*180/pi,EKF_x_save_llh(StartTime:EndTime,3),'g-');
plot3(LSQ_x_save_llh(StartTime:EndTime,2)*180/pi,LSQ_x_save_llh(StartTime:EndTime,1)*180/pi,LSQ_x_save_llh(StartTime:EndTime,3),'r*');
xlabel('Longitude (deg)');
ylabel('Latitude (deg)');
zlabel('Height (m)');
grid on;
title('GPS UKF Position Solution');

% figure(); hold on;
% plot(t_save,x_save_llh(:,1),'b-');
% plot(t_save,EKF_x_save_llh(:,1),'g-');
% plot(t_save,LSQ_x_save_llh(:,1),'r*');
% plot(sim_truth(:,1)/1000-37,sim_truth_llh(:,1),'r');
% plot([2:length(bestpos_2{13})+1],bestpos_2{13}*pi/180,'k')
% grid on;
% xlabel('Time (sec)');
% ylabel('North (m)');

% figure();hold on;
% plot(t_save(StartTime:EndTime)/60,x_hat_save(StartTime:EndTime,1)-sim_truth(TruthOffset+StartTime-1:length(sim_truth),2),'b');
% plot(t_save(StartTime:EndTime)/60,EKF_x_hat_save(StartTime:EndTime,1)-sim_truth(TruthOffset+StartTime-1:length(sim_truth),2),'g');
% plot(t_save(StartTime:EndTime)/60,LSQ_Solution(StartTime:EndTime,1)-sim_truth(TruthOffset+StartTime-1:length(sim_truth),2),'r');
% legend('UKF','EKF','LSQ');
% xlabel('Test Time (mins)');
% ylabel('Error (m)');
% grid on;



% figure();hold on;
% plot(x_hat_save(:,2)-sim_truth(39:length(sim_truth),3),'b');
% plot(EKF_x_hat_save(:,2)-sim_truth(39:length(sim_truth),3),'g');
% plot(LSQ_Solution(:,2)-sim_truth(39:length(sim_truth),3),'r');
% 
% figure();hold on;
% plot(x_hat_save(:,3)-sim_truth(39:length(sim_truth),4),'b');
% plot(EKF_x_hat_save(:,3)-sim_truth(39:length(sim_truth),4),'g');
% plot(LSQ_Solution(:,3)-sim_truth(39:length(sim_truth),4),'r');

% figure(); hold on;
% plot(t_save,x_save_llh(:,2),'b-');
% plot(t_save,EKF_x_save_llh(:,2),'g-');
% plot(t_save,LSQ_x_save_llh(:,2),'r*');
% plot(sim_truth(:,1)/1000-37,sim_truth_llh(:,2),'r');
% plot([2:length(bestpos_2{14})+1],bestpos_2{14}*pi/180,'k');
% grid on;
% xlabel('Time (sec)');
% ylabel('East (m)');

% figure(); hold on;
% plot(t_save,x_save_llh(:,3),'b-');
% plot(t_save,EKF_x_save_llh(:,3),'g-');
% plot(t_save,LSQ_x_save_llh(:,3),'r*');
% plot(sim_truth(39:length(sim_truth),1)/1000,sim_truth_llh(39:length(sim_truth),3),'r');
% plot([2:length(bestpos_2{15})+1],bestpos_2{15}+60,'k');
% grid on;
% xlabel('Time (sec)');
% ylabel('Height (m)');

% figure();
% subplot(3,1,[1 2]),plot(sim_truth_llh(StartTime+TruthOffset-1:length(sim_truth),2)*180/pi,sim_truth_llh(StartTime+TruthOffset-1:length(sim_truth),1)*180/pi,'b','LineWidth',2);
% title('Horizontal Profile');
% grid on;
% xlabel('Longitude (deg)');
% ylabel('Latitude (deg)');
% subplot(3,1,3),plot(t_save(StartTime:EndTime)/60,sim_truth_llh(StartTime+TruthOffset-1:length(sim_truth),3),'b','LineWidth',2);
% title('Vertical Profile');
% grid on;
% xlabel('Simulation Time (mins)');
% ylabel('Height AMSL (m)');
% axis([StartTime/60 EndTime/60 -100 1100]);


% figure(); hold on;
% plot(t_save,x_hat_save(:,1),'b-');
% %plot(t_save,EKF_x_hat_save(:,1),'g-');
% %plot(t_save,LSQ_Solution(:,1),'r*');
% plot(sim_truth(:,1)/1000-37,sim_truth(:,2),'g');
% grid on;
% xlabel('Time (sec)');
% ylabel('Height (m)');


%% plot velocities
% figure();hold on;
% % plot(t_save,x_save_vel(:,1));
% % plot(sim_truth(:,1)/1000-37,sim_truth_vel(:,1),'g');
% plot(x_save_vel(StartTime:EndTime,1)-sim_truth_vel(39+StartTime-1:length(sim_truth_vel),1),'r');
% plot(x_save_vel(StartTime:EndTime,2)-sim_truth_vel(39+StartTime-1:length(sim_truth_vel),2),'g');
% plot(x_save_vel(StartTime:EndTime,3)-sim_truth_vel(39+StartTime-1:length(sim_truth_vel),3),'b');
% grid on;
% xlabel('Time (sec)')
% ylabel('Velocity Error (m/s)');
% title('NED Velocity Errors');
% 
% 
% %plot(x_hat_save(:,1)-sim_truth(39:length(sim_truth),2),'r')
% 
% figure();
% plot(sim_truth(39:length(sim_truth),2),'r')
% hold on;
% plot(x_hat_save(:,1))
% 
% figure();
% plot(sim_truth(39:length(sim_truth),3),'r')
% hold on;
% plot(x_hat_save(:,2))
% 
% figure();
% plot(sim_truth(39:length(sim_truth),4),'r')
% hold on;
% plot(x_hat_save(:,3))
% 
% 
figure();
%plot(sim_truth(39:length(sim_truth),1),sim_truth(39:length(sim_truth),5),'r')
hold on;
plot(x_hat_save(:,4));
plot(EKF_x_hat_save(:,5),'g');
title('Velocity');

% 
% figure();
% plot(sim_truth(39:length(sim_truth),6),'r')
% hold on;
% plot(x_hat_save(:,5));
% plot(EKF_x_hat_save(:,6),'g');
% title('Velocity');

% figure();
% plot(sim_truth(39:length(sim_truth),7),'r')
% hold on;
% plot(x_hat_save(:,6))

% %% plot acceleration
% figure();
% plot(sim_truth(39:length(sim_truth),8),'r')
% hold on;
% plot(x_hat_save(:,9))
% title('Acceleration');
% 
figure();
%plot(sim_truth(39:length(sim_truth),9),'r')
hold on;
plot(x_hat_save(:,10));
plot(EKF_x_hat_save(:,10),'g');
title('Acceleration');
% 
% figure();
% plot(sim_truth(39:length(sim_truth),10),'r')
% hold on;
% plot(x_hat_save(:,11))
% title('Acceleration');
% 
% 
% 
% %% plot jerk
figure();
hold on;
plot(t_save+TruthOffset,x_hat_save(:,12),'b');
plot(t_save+TruthOffset,EKF_x_hat_save(:,12),'g');
%plot(pos_truth_ecef(1,:),jrk_truth_ecef(:,2),'r')
title('Jerk');
% 
% figure();
% plot(sim_truth(39:length(sim_truth),12),'r')
% hold on;
% plot(x_hat_save(:,13))
% title('Jerk');
% 
% figure();
% plot(sim_truth(39:length(sim_truth),12),'r')
% hold on;
% plot(x_hat_save(:,13))
% title('Jerk');
% 

%%


% figure();
% subplot(3,1,1),plot(t_save,x_save_llh(:,1)*180/pi);
% title('Position Solution');
% ylabel('Latitude (deg)');
% subplot(3,1,2),plot(t_save,x_save_llh(:,2)*180/pi);
% ylabel('Longitude (deg)');
% subplot(3,1,3),plot(t_save,x_save_llh(:,3));
% ylabel('Height (m-WGS84)');
% xlabel('Time (sec)');
% % 
% figure();
% subplot(3,1,1),plot(t_save,x_save_vel(:,1)); hold on; grid on;
% subplot(3,1,1),plot(t_save,2*S_save_vel(:,1),'r');
% subplot(3,1,1),plot(t_save,-2*S_save_vel(:,1),'r');
% title('Velocity Solution');
% ylabel('North (m/s)');
% subplot(3,1,2),plot(t_save,x_save_vel(:,2)); hold on; grid on;
% subplot(3,1,2),plot(t_save,2*S_save_vel(:,2),'r');
% subplot(3,1,2),plot(t_save,-2*S_save_vel(:,2),'r');
% ylabel('East (m/s)');
% subplot(3,1,3),plot(t_save,x_save_vel(:,3)); hold on; grid on;
% subplot(3,1,3),plot(t_save,2*S_save_vel(:,3),'r');
% subplot(3,1,3),plot(t_save,-2*S_save_vel(:,3),'r');
% ylabel('Down (m/s)');
% xlabel('Time (sec)');



% 
% subplot(3,1,1),plot(t_save,pos_error_llh(:,1));
% title('Position Error');
% hold on;
% subplot(3,1,1),plot(t_save,2*sqrt(P_save_llh(:,1)),'r');
% subplot(3,1,1),plot(t_save,-2*sqrt(P_save_llh(:,1)),'r');
% 
% subplot(3,1,2),plot(t_save,pos_error_llh(:,2));
% hold on;
% subplot(3,1,2),plot(t_save,2*sqrt(P_save_llh(:,2)),'r');
% subplot(3,1,2),plot(t_save,-2*sqrt(P_save_llh(:,2)),'r');
% 
% subplot(3,1,3),plot(t_save,pos_error_llh(:,3));
% hold on;
% subplot(3,1,3),plot(t_save,2*sqrt(P_save_llh(:,3)),'r');
% subplot(3,1,3),plot(t_save,-2*sqrt(P_save_llh(:,3)),'r');

% 
% figure();
% subplot(3,1,1),plot(t_save,x_save_vel(:,1));
% title('Velocity');
% subplot(3,1,2),plot(t_save,x_save_vel(:,2));
% subplot(3,1,3),plot(t_save,x_save_vel(:,3));
% 
% figure();
% subplot(3,1,1),plot(t_save,vel_error_ned(:,1));
% title('Velocity Error');
% subplot(3,1,2),plot(t_save,vel_error_ned(:,2));
% subplot(3,1,3),plot(t_save,vel_error_ned(:,3));
% 
% figure();
% subplot(3,1,1),plot(t_save,x_save_acc(:,1));
% title('Acceleration');
% subplot(3,1,2),plot(t_save,x_save_acc(:,2));
% subplot(3,1,3),plot(t_save,x_save_acc(:,3));
% 
% 


%% plot static positioning errors - UKF vs LSQ
figure();
subplot(3,1,1),plot(t_save/60,abs(NEDError_UKF(:,1)),'b'); hold on;
subplot(3,1,1),plot(t_save/60,2*S_save_NED(:,1),'b--');
%subplot(3,1,1),plot(t_save/60,-2*S_save_NED(:,1),'b--');
subplot(3,1,1),plot(t_save/60,abs(NEDError_LSQ(:,1)),'r');
subplot(3,1,1),plot(t_save/60,LSQ_DOP(:,3)*GPS_PR_UERE*2,'r--');
%subplot(3,1,1),plot(t_save/60,-LSQ_DOP(:,3)*GPS_PR_UERE*2,'r--');

subplot(3,1,1),plot(t_save/60,abs(NEDError_EKF(:,1)),'g');
subplot(3,1,1),plot(t_save/60,2*EKF_S_save_NED(:,1),'g--');

axis([t_save(1)/60,t_save(Epoch_lo)/60,00,40]);
grid on;
title('Static Positioning UKF and LSQ Errors');
legend('UKF Error','UKF 2-\sigma bound','LSQ Error','LSQ 2-\sigma bound','EKF Error','EKF 2-\sigma bound');
ylabel('North Error (m)');
xlabel('Test Time (mins)');

subplot(3,1,2),plot(t_save/60,abs(NEDError_UKF(:,2)),'b'); hold on;
subplot(3,1,2),plot(t_save/60,2*S_save_NED(:,2),'b--');
%subplot(3,1,2),plot(t_save/60,-2*S_save_NED(:,2),'b--');
subplot(3,1,2),plot(t_save/60,abs(NEDError_LSQ(:,2)),'r'); 
subplot(3,1,2),plot(t_save/60,LSQ_DOP(:,3)*GPS_PR_UERE*2,'r--');
%subplot(3,1,2),plot(t_save/60,-LSQ_DOP(:,3)*GPS_PR_UERE*2,'r--');

subplot(3,1,2),plot(t_save/60,abs(NEDError_EKF(:,2)),'g');
subplot(3,1,2),plot(t_save/60,2*EKF_S_save_NED(:,2),'g--');

axis([t_save(1)/60,t_save(Epoch_lo)/60,0,40]);
grid on;
ylabel('East Error (m)');
xlabel('Test Time (mins)');
subplot(3,1,3),plot(t_save/60,abs(NEDError_UKF(:,3)),'b'); hold on;
subplot(3,1,3),plot(t_save/60,2*S_save_NED(:,3),'b--');
%subplot(3,1,3),plot(t_save/60,-2*S_save_NED(:,3),'b--');
subplot(3,1,3),plot(t_save/60,abs(NEDError_LSQ(:,3)),'r');
subplot(3,1,3),plot(t_save/60,LSQ_DOP(:,4)*GPS_PR_UERE*2,'r--');
%subplot(3,1,3),plot(t_save/60,-LSQ_DOP(:,4)*GPS_PR_UERE*2,'r--');

subplot(3,1,3),plot(t_save/60,abs(NEDError_EKF(:,3)),'g');
subplot(3,1,3),plot(t_save/60,2*EKF_S_save_NED(:,3),'g--');

axis([t_save(1)/60,t_save(Epoch_lo)/60,0,40]);
grid on;
ylabel('Down Error (m)');
xlabel('Test Time (mins)');


%% plot horizontal error
figure();
hold on;grid on;
plot(t_save/60,sqrt(NEDError_UKF(:,1).^2+NEDError_UKF(:,2).^2),'k');
plot(t_save/60,sqrt(NEDError_EKF(:,1).^2+NEDError_EKF(:,2).^2),'k:');
plot(t_save/60,sqrt(NEDError_LSQ(:,1).^2+NEDError_LSQ(:,2).^2),'k:','LineWidth',1.5);
% plot covariances
plot(t_save/60,2*sqrt(S_save_NED(:,1).^2+S_save_NED(:,2).^2),'k');
plot(t_save/60,2*sqrt(EKF_S_save_NED(:,1).^2+EKF_S_save_NED(:,2).^2),'k:');
plot(t_save/60,LSQ_DOP(:,3)*GPS_PR_UERE*2,'k:','LineWidth',1.5);

xlabel('Test Time (mins)');
ylabel('Error (m)');
axis([t_save(StartTime)/60 t_save(EndTime)/60 0 15]);
title('Horizontal Position Error and Variance Estimate');
legend('UKF','EKF','LSQ');

%% plot vertical error
figure();
hold on;grid on;
plot(t_save/60,sqrt(NEDError_UKF(:,3).^2),'k');
plot(t_save/60,sqrt(NEDError_EKF(:,3).^2),'k:');
plot(t_save/60,sqrt(NEDError_LSQ(:,3).^2),'k:','LineWidth',1.5);
% plot covariances
plot(t_save/60,2*S_save_NED(:,3),'k');
plot(t_save/60,2*EKF_S_save_NED(:,3),'k:');
plot(t_save/60,LSQ_DOP(:,4)*GPS_PR_UERE*2,'k:','LineWidth',1.5);

xlabel('Test Time (mins)');
ylabel('Error (m)');
axis([t_save(StartTime)/60 t_save(EndTime)/60 0 15]);
title('Vertical Position Error and Variance Estimate');
legend('UKF','EKF','LSQ');



% 
% figure();
% subplot(3,1,1),plot(t_save/60,NEDError_UKF(:,1),'b'); hold on;
% subplot(3,1,1),plot(t_save/60,2*S_save_NED(:,1),'r');
% subplot(3,1,1),plot(t_save/60,-2*S_save_NED(:,1),'r'); 
% 
% grid on;
% title('UKF Error Bounds');
% ylabel('North Error (m)');
% subplot(3,1,2),plot(t_save/60,NEDError_UKF(:,2),'b'); hold on;
% subplot(3,1,2),plot(t_save/60,2*S_save_NED(:,2),'r'); 
% subplot(3,1,2),plot(t_save/60,-2*S_save_NED(:,2),'r'); 
% 
% grid on;
% ylabel('East Error (m)');
% subplot(3,1,3),plot(t_save/60,NEDError_UKF(:,3),'b'); hold on;
% subplot(3,1,3),plot(t_save/60,2*S_save_NED(:,3),'r');
% subplot(3,1,3),plot(t_save/60,-2*S_save_NED(:,3),'r');
% 
% grid on;
% ylabel('Down Error (m)');
% xlabel('Test Time (mins)');

% 
% figure();
% plot(t_save/60,x_hat_save(:,7))
% grid on;
% xlabel('Test Time (mins)');
% ylabel('Clock Estimates (m)');
% title('Receiver Clock Bias');

%% plot residuals
% figure();
% subplot(2,1,1),plot(t_save/60,z_save(:,1:NumberGPSMeasurements));
% axis([0 Epoch_lo/60 -3 3]);
% ylabel('UKF Residuals');
% xlabel('Test Time (mins)');
% legend(num2str((SV_Vec(1:NumberGPSMeasurements)')));
% grid on;
% subplot(2,1,2),plot(t_save/60,LSQ_ResidualVector(:,1:NumberGPSMeasurements));
% %axis([0 Epoch_lo/60 -3 3]);
% ylabel('LSQ Residuals');
% xlabel('Test Time (mins)');
% legend(num2str((SV_Vec(1:NumberGPSMeasurements)')));
% grid on;


% for i=1:NumberGPSMeasurements
%     figure();
%     plot(t_save/60,z_save(:,i),'b'); hold on;
%     plot(t_save/60,LSQ_ResidualVector(:,i),'r');
%     plot(t_save/60,EKF_z_save(:,i),'g');
%     xlabel('Test Time (mins)');
%     ylabel('Residual (m)');
%     legend('UKF','LSQ','EKF');
%     title(sprintf('Measurement Residual for SV%d',SV_Vec(i)))
%     grid on;
%     axis([t_save(1)/60 t_save(NumberEpochsGPS)/60 -2 2]);
% end

% figure();
% plot(t_save/60,z_save(:,1:NumberGPSMeasurements));
% hold on;
% plot(t_save/60,LSQ_ResidualVector(:,1:NumberGPSMeasurements));
% legend(num2str((SV_Vec(1:NumberGPSMeasurements)')));
% grid on;
% xlabel('Test Time (min)');
% ylabel('Residuals');

% %% plot clock estimate
% figure();
% plot(t_save/60,x_hat_save(:,7),'b');
% hold on;
% plot(t_save/60,LSQ_Solution(:,4),'r');
% grid on;
% plot(t_save/60,EKF_x_hat_save(:,4),'g');
% xlabel('Test Time (mins)');
% ylabel('Clock Estimates (m)');
% %axis([0 Epoch_lo/60 6 16]);
% title('Receiver Clock Bias');
% legend('UKF','LSQ','EKF');

% %% plot DOPs
% figure();
% subplot(3,1,1),plot(t_save/60,DOP_UKF(:,3),'b'); hold on;
% subplot(3,1,1),plot(t_save/60,LSQ_DOP(:,3),'r'); grid on;
% ylabel('HDOP');
% title('DOP Values Calculated by UKF and Least-Squares');
% legend('UKF','LSQ');
% subplot(3,1,2),plot(t_save/60,DOP_UKF(:,4),'b'); hold on;
% subplot(3,1,2),plot(t_save/60,LSQ_DOP(:,4),'r'); grid on;
% ylabel('VDOP');
% 
% subplot(3,1,3),plot(t_save/60,DOP_UKF(:,5),'b'); hold on;
% subplot(3,1,3),plot(t_save/60,LSQ_DOP(:,5),'r'); grid on;
% ylabel('TDOP');
% xlabel('Test Time (minutes)');



% %% calculate the RMS error
% %Height_RMS = sqrt(sum(Height_error.^2)/NumberEpochsINS)'
% North_RMS_LSQ = sqrt(sum(NEDError_LSQ(:,1).^2)/NumberEpochsGPS)
% North_RMS_EKF = sqrt(sum(NEDError_EKF(:,1).^2)/NumberEpochsGPS)
% North_RMS_UKF = sqrt(sum(NEDError_UKF(:,1).^2)/NumberEpochsGPS)
% 
% East_RMS_LSQ = sqrt(sum(NEDError_LSQ(:,2).^2)/NumberEpochsGPS)
% East_RMS_EKF = sqrt(sum(NEDError_EKF(:,2).^2)/NumberEpochsGPS)
% East_RMS_UKF = sqrt(sum(NEDError_UKF(:,2).^2)/NumberEpochsGPS)
% 
% Down_RMS_LSQ = sqrt(sum(NEDError_LSQ(:,3).^2)/NumberEpochsGPS)
% Down_RMS_EKF = sqrt(sum(NEDError_EKF(:,3).^2)/NumberEpochsGPS)
% Down_RMS_UKF = sqrt(sum(NEDError_UKF(:,3).^2)/NumberEpochsGPS)
% 
% 
North_RMS_LSQ_sub = sqrt(sum(NEDError_LSQ(300:length(NEDError_LSQ),1).^2)/(NumberEpochsGPS-300))
North_RMS_EKF_sub = sqrt(sum(NEDError_EKF(300:length(NEDError_LSQ),1).^2)/(NumberEpochsGPS-300))
North_RMS_UKF_sub = sqrt(sum(NEDError_UKF(300:length(NEDError_LSQ),1).^2)/(NumberEpochsGPS-300))

East_RMS_LSQ_sub = sqrt(sum(NEDError_LSQ(300:length(NEDError_LSQ),2).^2)/(NumberEpochsGPS-300))
East_RMS_EKF_sub = sqrt(sum(NEDError_EKF(300:length(NEDError_LSQ),2).^2)/(NumberEpochsGPS-300))
East_RMS_UKF_sub = sqrt(sum(NEDError_UKF(300:length(NEDError_LSQ),2).^2)/(NumberEpochsGPS-300))

Down_RMS_LSQ_sub = sqrt(sum(NEDError_LSQ(300:length(NEDError_LSQ),3).^2)/(NumberEpochsGPS-300))
Down_RMS_EKF_sub = sqrt(sum(NEDError_EKF(300:length(NEDError_LSQ),3).^2)/(NumberEpochsGPS-300))
Down_RMS_UKF_sub = sqrt(sum(NEDError_UKF(300:length(NEDError_LSQ),3).^2)/(NumberEpochsGPS-300))

RMS3D_LSQ_sub = sqrt(North_RMS_LSQ_sub^2 + East_RMS_LSQ_sub^2 + Down_RMS_LSQ_sub^2)
RMS3D_EKF_sub = sqrt(North_RMS_EKF_sub^2 + East_RMS_EKF_sub^2 + Down_RMS_EKF_sub^2)
RMS3D_UKF_sub = sqrt(North_RMS_UKF_sub^2 + East_RMS_UKF_sub^2 + Down_RMS_UKF_sub^2)

% plot sigma points
%     plot(Epoch_lo,xs_i_k(1,:),'b.'); hold on;
%     plot(Epoch_lo,xs_0_k(1),'r.');
% figure();grid on; hold on;
% plot(sigma_points(:,2:2*Na+1),'b.');
% plot(sigma_points(:,1),'r.');
% plot(sim_truth(39:length(sim_truth),2),'r');hold on;
%plot(sim_truth(39:length(sim_truth),19),'b');

% figure();
% plot(t_save(StartTime:EndTime)/60,UKF_HPL(StartTime:EndTime),'k-');
% hold on;
% plot(t_save(StartTime:EndTime)/60,EKF_HPL(StartTime:EndTime),'k--');
% plot(t_save(StartTime:EndTime)/60,LSQ_RAIM_HPL(StartTime:EndTime),'k:');
% %grid on;
% axis([StartTime/60 EndTime/60 0 150]);
% xlabel('Time (mins)');
% ylabel('Protection Level (m)');
% title('Horizontal Protection Level');
% legend('UKF','EKF','LSQ');
% 
% figure;
% plot(t_save(StartTime:EndTime)/60,UKF_VPL(StartTime:EndTime),'k-');
% hold on;
% plot(t_save(StartTime:EndTime)/60,EKF_VPL(StartTime:EndTime),'k--');
% plot(t_save(StartTime:EndTime)/60,LSQ_RAIM_VPL(StartTime:EndTime),'k:');
% %grid on;
% axis([StartTime/60 EndTime/60 0 150]);
% xlabel('Time (mins)');
% ylabel('Protection Level (m)');
% title('Vertical Protection Level');
% legend('UKF','EKF','LSQ');

figure();
plot(t_save/60,UKF_HPL,'k-');
hold on;grid on;
plot(t_save/60,EKF_HPL,'k:');
plot(t_save/60,LSQ_RAIM_HPL,'k:','LineWidth',1.5);
xlabel('Test Time (mins)');
ylabel('Protection Level (m)');
title('Horizontal Protection Level');
legend('UKF','EKF','LSQ');
axis([StartTime/60 EndTime/60 0 50]);

figure();
plot(t_save/60,UKF_HPL,'b','LineWidth',2);
hold on;
plot(t_save/60,EKF_HPL,'r','LineWidth',2);
plot(t_save/60,LSQ_RAIM_HPL,'g','LineWidth',2);
xlabel('Test Time (mins)');
ylabel('Protection Level (m)');
title('Horizontal Protection Level');
legend('UKF','EKF','LSQ');
axis([StartTime/60 EndTime/60 0 50]);
grid on;


figure();
plot(t_save/60,UKF_VPL,'k-');
hold on; grid on;
plot(t_save/60,EKF_VPL,'k:');
plot(t_save/60,LSQ_RAIM_VPL,'k:','LineWidth',1.5);
xlabel('Test Time (mins)');
ylabel('Protection Level (m)');
title('Vertical Protection Level');
legend('UKF','EKF','LSQ');
axis([StartTime/60 EndTime/60 0 120]);

% 
% %% plot DOPs         
% figure();hold on;grid on;
% plot(t_save(StartTime:EndTime)/60,DOP_UKF(StartTime:EndTime,3),'b');
% plot(t_save(StartTime:EndTime)/60,DOP_UKF(StartTime:EndTime,4),'r');
% plot(t_save(StartTime:EndTime)/60,DOP_UKF(StartTime:EndTime,5),'g');
% legend('HDOP','VDOP','TDOP');
% xlabel('Test Time (mins)')
% ylabel('DOP Value');

HAL = 20;
figure();hold on;
plot(sqrt(NEDError_UKF(100:length(NEDError_UKF),1).^2+NEDError_UKF(100:length(NEDError_UKF),2).^2),UKF_HPL(100:length(NEDError_UKF)),'b.');
plot(sqrt(NEDError_EKF(100:length(NEDError_EKF),1).^2+NEDError_EKF(100:length(NEDError_EKF),2).^2),EKF_HPL(100:length(NEDError_EKF)),'r.');
plot(sqrt(NEDError_LSQ(:,1).^2+NEDError_LSQ(:,2).^2),LSQ_RAIM_HPL,'g.');
%area([HAL 100],[HAL HAL],'FaceColor','r');
plot([0 100],[HAL HAL],'k','LineWidth',2);
plot([HAL HAL],[0 HAL],'k','LineWidth',2);
axis([0 100 0 100]);
text(12,5,'MI');
text(52,5,'HMI');
text(52,35,'MI');
plot([0:3000],[0:3000],'k-','LineWidth',2);
xlabel('Position Error (m)');
ylabel('Protection Level (m)');
legend('UKF','EKF','LSQ');
grid on;
title('Horizontal Stanford Plot');

VAL = 50;
figure();
plot(abs(NEDError_UKF(100:length(NEDError_UKF),3)),UKF_VPL(100:length(NEDError_UKF)),'b.');
hold on;
plot(abs(NEDError_EKF(100:length(NEDError_EKF),3)),EKF_VPL(100:length(NEDError_EKF)),'r.');
plot(sqrt(NEDError_LSQ(:,1).^2+NEDError_LSQ(:,2).^2),LSQ_RAIM_HPL,'g.');
plot([0 100],[VAL VAL],'k','LineWidth',2);
plot([VAL VAL],[0 VAL],'k','LineWidth',2);
axis([0 100 0 100]);
plot([0:3000],[0:3000],'k-','LineWidth',2);
text(32,15,'MI');
text(72,25,'HMI');
text(72,65,'MI');
xlabel('Position Error (m)');
ylabel('Protection Level (m)');
legend('UKF','EKF','LSQ');
grid on;
title('Vertical Stanford Plot');

% figure(); grid on; hold on;
% for i=1:81
% plot(xdot_sigma_points(:,i)-xdot_sigma_points(:,1));
% hold on;
% end

% 
% figure();hold on;
% plot(pos_truth_ecef(1,:),pos_truth_ecef(2,:),'r');
% plot(t_save+TruthOffset,x_hat_save(:,1),'b');


figure; hold on; grid on;
plot(t_save,UKF_TD_H);
plot(t_save,UKF_lambda_ss);
plot(t_save,UKF_HPL,'k','LineWidth',2);
line([506 506],[0 20],[0 0],'LineWidth',2,'LineStyle','--','Color','black');
axis([480 520 0 20]);
xlabel('Test Time (sec)');
ylabel('Horizontal (m)');


figure; hold on; grid on;
plot(t_save,EKF_TD_H);
plot(t_save,EKF_lambda_ss);
plot(t_save,EKF_HPL,'k','LineWidth',2);
line([507 507],[0 20],[0 0],'LineWidth',2,'LineStyle','--','Color','black');
axis([480 520 0 20]);
xlabel('Test Time (sec)');
ylabel('Horizontal (m)');


figure; hold on; grid on;
plot(t_save,UKF_TD_H);
plot(t_save,UKF_lambda_ss);
plot(t_save,UKF_HPL,'k','LineWidth',2);
line([506 506],[0 20],[0 0],'LineWidth',2,'LineStyle','-','Color','black');
plot(t_save,EKF_TD_H);
plot(t_save,EKF_lambda_ss);
plot(t_save,EKF_HPL,'k--','LineWidth',2);
line([507 507],[0 20],[0 0],'LineWidth',2,'LineStyle','--','Color','black');
axis([480 520 0 20]);
xlabel('Test Time (sec)');
ylabel('Horizontal (m)');

