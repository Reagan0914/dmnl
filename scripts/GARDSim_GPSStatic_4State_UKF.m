%% GPS Position Solution using UKF
% Written by Duncan Greer 2 Feb 2007
%
% $Id: GARDSim_GPSStatic_4State_UKF.m 1879 2008-07-15 05:20:21Z n2523710 $
%
%
%
%
%
% x1  = ECEF X
% x2  = ECEF Y
% x3  = ECEF Z
% x4  = ECEF X Velocity
% x5  = ECEF Y Velocity
% x6  = ECEF Z Velocity
% x7  = Receiver Clock Bias (Rb)
% x8  = Receiver Clock Drift Rate (Rf)
%


%% setup simulation

% set number formatting for display
format long g;

% load GPS constants
GPSConstants;

%% Load data - Note, this mat file is generated by the commented code
%% below.
%load 'data/Ground_Test_Data/2Feb2007/flexpak.mat';

load 'data/Ground_Test_Data/22Feb2007/flexpak.mat';
% a hack for this file = approx pos is wrong
ApproxPos = [-5046719.69001578,2568403.35951166,-2925318.76002602];
meanECEF =  [-5046773.35774802  2568446.08440315 -2925289.01760974];

ALPHA = [9.3132E-09  0.0000E+00 -5.9605E-08  0.0000E+00];
BETA = [9.0112D+04  0.0000E+00 -1.9661E+05  0.0000E+00];

% load observation and nav data
% [GPSTime_Week, GPSTime_Sec,NumberRinexObsTypes,ValidDataRinexObs,ApproxPos, Novatel_C1, Novatel_L1, Novatel_D1, Novatel_S1, Novatel_P2, Novatel_L2, Novatel_D2, Novatel_S2] =...
%                 ReadRinexNovatel('data/Ground_Test_Data/22Feb2007/nova0530.07O');
% 
% [GPSTime_Week, GPSTime_Sec,NumberRinexObsTypes,ApproxPos, DATA_STRUCT] = ReadRinexGRS('data/Ground_Test_Data/22Feb2007/nova0530.07O');
%             
% [SV_Ephemeris, ALPHA, BETA] = freadnav('data/Ground_Test_Data/22Feb2007/nova0530.07N');
% 
% 
% % copy data struct memebers to variables
% Novatel_C1 = DATA_STRUCT.C1(:,:);
% Novatel_L1 = DATA_STRUCT.L1(:,:);
% Novatel_S1 = DATA_STRUCT.S1(:,:);
% Novatel_D1 = DATA_STRUCT.D1(:,:);

NumberEpochsGPS = size(Novatel_C1,2);
gps_dt = 1;

NumberSVs = size(Novatel_C1,1);
SVDontUse = zeros(1,NumberSVs);

% % propogate satellite orbits and velocities
% disp('Calculating Satellite Orbits...');
%  
% % preallocate storage vectors for speed
% SV_X_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Y_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Z_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_T_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Xvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Yvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Zvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Tvel_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Xacc_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Yacc_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Zacc_Data = zeros(NumberEpochsGPS,NumberSVs);
% SV_Tacc_Data = zeros(NumberEpochsGPS,NumberSVs);
%  
% for i=1:NumberEpochsGPS
%     for j=1:NumberSVs
%         [SV_X_Data(i,j), SV_Y_Data(i,j), SV_Z_Data(i,j), SV_T_Data(i,j), ValidPosData(i,j)] = ...
%                GPSOrbitPropagator(GPSTime_Week(i), GPSTime_Sec(i), j, SV_Ephemeris, 7500);
%         [SV_Xvel_Data(i,j), SV_Yvel_Data(i,j), SV_Zvel_Data(i,j), SV_Tvel_Data(i,j), ...
%          SV_Xacc_Data(i,j), SV_Yacc_Data(i,j), SV_Zacc_Data(i,j), SV_Tacc_Data(i,j), ValidVelData(i,j)] = ...
%          GPSOrbitPropagatorVelocities(GPSTime_Week(i),GPSTime_Sec(i), j, SV_Ephemeris);
%     end
%     
%     if(mod(i,1000) == 0)
%         disp(sprintf('Completed Epoch %d',i));
%     end
% end
% 


%% arrange pseudorange measurements

PR_Sim = Novatel_C1';
PRR_Sim = Novatel_D1' * L1_Wavelength;
CP_Sim = Novatel_L1';

% position
[InitialPosition(1),InitialPosition(2),InitialPosition(3)] = ECEF2LLH(ApproxPos);
% velocity
InitialVelocity = [0 0 0]';  % NED velocities in m/s

% get the initial meridian and prime radii of curvature
RM = MeridianRadius(InitialPosition(2));
RP = PrimeRadius(InitialPosition(2));

% 3 position, 3 velocity and 2 clock
NumberStates = 4;

% process noise states - 8
ProcessNoiseStates = 4;  

% use a maximum of 8 measurements (PR+PRR)
MeasurementNoiseStates=6;


Na = NumberStates+ProcessNoiseStates+MeasurementNoiseStates;

% UKF scaling parameters
alpha = 1; % range: 1e-3 < alpha <= 1
beta = 2;  % 2 is optimal for gaussian priors
kapa = 0;  %

LAMBDA = alpha^2 * (Na+kapa) - Na;



TimeGPS = [0:gps_dt:NumberEpochsGPS-1];


NEDError_UKF = zeros(NumberEpochsGPS,3);
ECEFError_UKF = zeros(NumberEpochsGPS,3);
NEDError_LSQ = zeros(NumberEpochsGPS,3);
ECEFError_LSQ = zeros(NumberEpochsGPS,3);

%% initialise covariances
Px_kminus = eye(NumberStates,NumberStates)*10000;
Px_kminus(4,4) = 1000000000;

Q = eye(ProcessNoiseStates,ProcessNoiseStates) * 1;
Q(4,4) = 1000;

R = eye(MeasurementNoiseStates,MeasurementNoiseStates)*7.5*7.5;
%R(1:5,1:5) = eye(5,5)*7.5*7.5;
%R(6:10,6:10) = eye(5,5)*3*3;

x_hat_kminus = zeros(NumberStates,1);
x_hat_kminus(1:3,1) = ApproxPos;  %% use the approximate position from the RINEX file
GRASOn = 0; %% no gras corrections - use Nav data for IONO model


SV_Azimuth = zeros(NumberEpochsGPS,NumberSVs);
SV_Elevation =  zeros(NumberEpochsGPS,NumberSVs);

SVDontUse(25) = 1;
SVDontUse(16) = 1;
SVDontUse(20) = 1;

URALimit = 1;

%% loop through and check for SV unhealthy (Ephemeris param 27)
for i=1:size(SV_Ephemeris,1)
   
   % check for unhealthy flag 
   if(SV_Ephemeris(i,27) ~= 0)
       disp(sprintf('SV %d Ephemeris Unhealthy',SV_Ephemeris(i,1)));
      SVDontUse(SV_Ephemeris(i,1)) = 1;
   end
   
   % check for large URA
   
   if(SV_Ephemeris(i,26) > URALimit)
       disp(sprintf('SV %d URA Exceeds Limit (%d)',SV_Ephemeris(i,1),URALimit));
      SVDontUse(SV_Ephemeris(i,1)) = 1;
   end
   
end



%% range error
RangeError = zeros(1,NumberSVs);
RangeErrorRate = zeros(1,NumberSVs);

RangeErrorRate(1,3) = 0.0;


%% start gps solutions
for Epoch_lo = 1:NumberEpochsGPS

    % get the gps time - used for the iono correction
    %GPSTime  = 259199 + Epoch_lo;
    GPSTime = GPSTime_Sec(Epoch_lo);
    
    RangeError = RangeError + RangeErrorRate*gps_dt;
    PR_Sim(Epoch_lo,:) = PR_Sim(Epoch_lo,:) + RangeError; 

    % perform state prediction
    % generate augmented state vector
    if Epoch_lo == 1
        % initialise mean and covariance
        xa_hat_kminus = [x_hat_kminus;zeros(ProcessNoiseStates,1);zeros(MeasurementNoiseStates,1)];

        Pxa_kminus = [Px_kminus          zeros(NumberStates,NumberStates) zeros(NumberStates,MeasurementNoiseStates);
                  zeros(ProcessNoiseStates,NumberStates) Q           zeros(ProcessNoiseStates,MeasurementNoiseStates);
                  zeros(MeasurementNoiseStates,NumberStates) zeros(MeasurementNoiseStates,ProcessNoiseStates)  R];

    else
        xa_hat_kminus(1:NumberStates) = x_hat_kplus;
        % update state covariance element
        Pxa_kminus(1:NumberStates,1:NumberStates) = Px_kplus;
        
    end
          
          
          
    blah = sqrt(Na+LAMBDA) * chol(Pxa_kminus);
    for i=0:Na
        if i==0
            xs_0 = xa_hat_kminus;
            W_0_m = LAMBDA / (Na + LAMBDA);
            W_0_c = W_0_m + (1 - alpha^2 + beta);
        else
            xs_i(:,i) = xa_hat_kminus + blah(:,i);
            xs_i(:,i+Na) = xa_hat_kminus - blah(:,i);
            W_i_m = 1 / (2 * (Na + LAMBDA));
            W_i_c = W_i_m;
        end
    end

    
    
    
    
    % propagate system dynamics
    for i=0:2*Na
        if i==0
            %% zeroth point
            
            % position
%             xs_0_k(1) = xs_0(1) + xs_0(4)*gps_dt;
%             xs_0_k(2) = xs_0(2) + xs_0(5)*gps_dt;
%             xs_0_k(3) = xs_0(3) + xs_0(6)*gps_dt;
%             xs_0_k(7) = xs_0(7) + xs_0(8)*gps_dt;
            xs_0_k(1) = xs_0(1);
            xs_0_k(2) = xs_0(2);
            xs_0_k(3) = xs_0(3);
            xs_0_k(4) = xs_0(4);
            
            % velocity
%             xs_0_k(4) = xs_0(4);
%             xs_0_k(5) = xs_0(5);
%             xs_0_k(6) = xs_0(6);
%             xs_0_k(8) = xs_0(8);
%             xs_0_k(4) = xs_0(4) + xs_0(9)*gps_dt;
%             xs_0_k(5) = xs_0(5) + xs_0(10)*gps_dt;
%             xs_0_k(6) = xs_0(6) + xs_0(11)*gps_dt;
%             xs_0_k(8) = xs_0(8);
%             
%             % acceleration
%             xs_0_k(9) = xs_0(9);
%             xs_0_k(10) = xs_0(10);
%             xs_0_k(11) = xs_0(11);
%             
            
            
            %% add process noise
            V = xs_0(NumberStates+1:NumberStates+ProcessNoiseStates)';
            xs_0_k(1:NumberStates) = xs_0_k(1:NumberStates) + V;
            
            
        else
            
            % i-points
            
            % position
%             xs_i_k(1,i) = xs_i(1,i) + xs_i(4,i)*gps_dt;
%             xs_i_k(2,i) = xs_i(2,i) + xs_i(5,i)*gps_dt;
%             xs_i_k(3,i) = xs_i(3,i) + xs_i(6,i)*gps_dt;
%             xs_i_k(7,i) = xs_i(7,i) + xs_i(8,i)*gps_dt;
            xs_i_k(1,i) = xs_i(1,i);
            xs_i_k(2,i) = xs_i(2,i);
            xs_i_k(3,i) = xs_i(3,i);
            xs_i_k(4,i) = xs_i(4,i);
            
            % velocity
%             xs_i_k(4,i) = xs_i(4,i) + xs_i(9,i)*gps_dt;
%             xs_i_k(5,i) = xs_i(5,i) + xs_i(10,i)*gps_dt;
%             xs_i_k(6,i) = xs_i(6,i) + xs_i(11,i)*gps_dt;
%             xs_i_k(8,i) = xs_i(8,i);
%             xs_i_k(4,i) = xs_i(4,i);
%             xs_i_k(5,i) = xs_i(5,i);
%             xs_i_k(6,i) = xs_i(6,i);
%             xs_i_k(8,i) = xs_i(8,i);
            % acceleration
%             xs_i_k(9,i) = xs_i(9,i);
%             xs_i_k(10,i) = xs_i(10,i);
%             xs_i_k(11,i) = xs_i(11,i);
            
            
            
            %% add process noise
            V = xs_i(NumberStates+1:NumberStates+ProcessNoiseStates,i);
            xs_i_k(1:NumberStates,i) = xs_i_k(1:NumberStates,i) + V;
        end
    end
    
    
    
    
    
    
    
    
    W = eye(1,2*Na+1);
    W(1,1) = W_0_m;
    W(1,2:2*Na+1) = W_i_m;
    X = zeros(NumberStates,2*Na+1);
    X(:,1) = xs_0_k(1:NumberStates);
    X(:,2:2*Na+1) = xs_i_k(1:NumberStates,:);
    x_hat_kminus = (W*X')';

    nx = length(x_hat_kminus); nw = length(W);
    Px_kminus=((ones(nx,1)*W).*(X-x_hat_kminus*ones(1,nw)))*(X-x_hat_kminus*ones(1,nw))';
        
    % initial guess at user pos required to estimate earth rotation
    % correction
    UserPos(1:3) = [x_hat_kminus(1);x_hat_kminus(2);x_hat_kminus(3)];
 %   UserPos(4) = xs_0_k(7);
        
    % format the input measurement vectors
    SVIndex = 0;
    

    clear PR_Vec PRR_Vec SV_Vec SVPos SVPos2;
    
    for SV=1:NumberSVs
        if((PR_Sim(Epoch_lo,SV) > 100) && SVDontUse(SV) == 0)  %%SV ~= ExcludeSVPRN
            
            % add to PR vector
            SVIndex = SVIndex + 1;

            SV_Vec(SVIndex) = SV;
            PR_Vec(SVIndex) = PR_Sim(Epoch_lo,SV);
            PRR_Vec(SVIndex) = PRR_Sim(Epoch_lo,SV);
            
            
            
            
            if(Epoch_lo == 1)
                %PRR_Vec(SVIndex) = 0;
                PR_csc(SVIndex) = PR_Vec(SVIndex);
            else
                if(CP_Sim(Epoch_lo-1,SV) == 0)
                    %PRR_Vec(SVIndex) = (CP_Sim(Epoch_lo+1,SV) - CP_Sim(Epoch_lo,SV));
                    PR_csc(SVIndex) = PR_Vec(SVIndex);
                else
                    %PRR_Vec(SVIndex) = (CP_Sim(Epoch_lo,SV) - CP_Sim(Epoch_lo-1,SV));

                 %%% PERFORM CARRIER PHASE SMOOTHING of PR
                 %%% HERE


                    %alpha_carriersmooth = gps_dt/100;
                    %P_proj = PR_prev + (L1_Wavelength/(2*pi))*(CP_Sim(Epoch_lo) - CP_Sim(Epoch_lo-1));
                    %PR_csc(SVIndex) = alpha_carriersmooth * PR_Vec(SVIndex) + (1-alpha_carriersmooth)*P_proj;                            

                end
            end
            % save previous value
            %PR_prev = PR_csc(SVIndex);

            % dont use the carrier smoothed code
            %PR_Vec = PR_csc;                  

            %SVPos(SVIndex,:) = [SV_X_Data(Epoch_lo,SV) SV_Y_Data(Epoch_lo,SV) SV_Z_Data(Epoch_lo,SV) SV_T_Data(Epoch_lo,SV)*c];
            %SVVel(SVIndex,:) = [SV_Xvel_Data(Epoch_lo,SV) SV_Yvel_Data(Epoch_lo,SV) SV_Zvel_Data(Epoch_lo,SV) SV_Tvel_Data(Epoch_lo,SV)*c];
            %SVAcc(SVIndex,:) = [SV_Xacc_Data(Epoch_lo,SV) SV_Yacc_Data(Epoch_lo,SV) SV_Zacc_Data(Epoch_lo,SV) SV_Tacc_Data(Epoch_lo,SV)*c];

            [SVPos(SVIndex,1), SVPos(SVIndex,2), SVPos(SVIndex,3), SVPos(SVIndex,4), ValidPosData(Epoch_lo,SV)] = ...
               GPSOrbitPropagator(GPSTime_Week(Epoch_lo), GPSTime_Sec(Epoch_lo) - PR_Vec(SVIndex)/Speedoflight, SV, SV_Ephemeris, 7500);
            
           % convert satellite clock to metres
            SVPos(SVIndex,4) = SVPos(SVIndex,4)*Speedoflight;
                        
            [SV_Azimuth(Epoch_lo,SV), SV_Elevation(Epoch_lo,SV)] = AzEl(UserPos(1:3), SVPos(SVIndex,1:3));

            % calculate the iono delay correction - single frequency user
            % model from ICD 200
            if(GRASOn == 0)
                ionodelay = ionomodel(GPSTime, UserPos(1:3), SVPos(SVIndex,1:3), ALPHA, BETA);
                PR_Vec(SVIndex) = PR_Vec(SVIndex) - ionodelay;
                
                Iono_save(Epoch_lo,SV_Vec(SVIndex)) = ionodelay;
            end

            % calculate hte earth rotation correction as per Kayton pg 228
            % eq 5.67

            delta_pr_omegaedot = -(OMEGAedot / Speedoflight) * (SVPos(SVIndex,1) *UserPos(2) - SVPos(SVIndex,2) * UserPos(1));
            PR_Vec_raw(SVIndex) = PR_Vec(SVIndex);  % save a raw (uncorrected copy) of the PR vector for use in the LSQ algorithm later.
            PR_Vec(SVIndex) = PR_Vec(SVIndex) + SVPos(SVIndex,4) + delta_pr_omegaedot;  %% add earth rotation and satellite clock correction


            % calculate the *true* range to this satellite
            TrueSVRange(Epoch_lo,SVIndex) = magnitude(SVPos(SVIndex,1:3) - meanECEF);
            
            DeltaSVRange(Epoch_lo,SVIndex) = PR_Vec(SVIndex) - TrueSVRange(Epoch_lo,SVIndex);
            

        end
    end

    NumberGPSMeasurements = length(PR_Vec);



    if NumberGPSMeasurements > MeasurementNoiseStates
        NumberGPSMeasurements = MeasurementNoiseStates;
    end
    
   

    % formulate the measurment vector
    %y_k = [PR_Vec(1:NumberGPSMeasurements)';PRR_Vec(1:NumberGPSMeasurements)'];
    y_k = [PR_Vec(1:NumberGPSMeasurements)'];

    
    
    

    for k = 1:NumberGPSMeasurements
        % find apriori estimate of pseudorange for each sigma point

        % zero-th sigma point

        
        % Get User position in ECEF
        UserPos(1:3) = [xs_0_k(1);xs_0_k(2);xs_0_k(3)];
        %UserPos(4) = xs_0_k(7);
        UserPos(4) = xs_0_k(4);
        %UserVel(1:3) =  [xs_0_k(4);xs_0_k(5);xs_0_k(6)];
        %UserVel(4) = xs_0_k(8);
        
        geo_range_to_sat = sqrt((SVPos(k,1) - UserPos(1))^2 + (SVPos(k,2) - UserPos(2))^2 + (SVPos(k,3) - UserPos(3))^2);
        %geo_vel_to_sat = (SVVel(k,1) - UserVel(1))*(SVPos(k,1)-UserPos(1)) + (SVVel(k,2) - UserVel(2))*(SVPos(k,2)-UserPos(2)) + (SVVel(k,3) - UserVel(3))*(SVPos(k,3)-UserPos(3));

    %% calculate measurement predicition
        % pseudorange prediction
        PR_Vec_minus_0(k) = geo_range_to_sat + UserPos(4) + xs_0(NumberStates+ProcessNoiseStates+k);% + UserVel(4) * gps_dt;  % geometric range + c * delta_T
        %predicted relative velocity of sv and receiver
        %Relative_Velocity(k) = geo_vel_to_sat/geo_range_to_sat;
        %PRR_Vec_minus_0(k) = Relative_Velocity(k) + UserVel(4);

        for i=1:2*Na
            % Get User position in ECEF
            UserPos(1:3) = [xs_i_k(1,i);xs_i_k(2,i);xs_i_k(3,i)];
            %UserPos(4) = xs_i_k(7,i);
            UserPos(4) = xs_i_k(4,i);
            %UserVel(1:3) =  [xs_i_k(4,i);xs_i_k(5,i);xs_i_k(6,i)];
            %UserVel(4) = xs_i_k(8,i);
            
            
            geo_range_to_sat = sqrt((SVPos(k,1) - UserPos(1))^2 + (SVPos(k,2) - UserPos(2))^2 + (SVPos(k,3) - UserPos(3))^2);
            %geo_vel_to_sat = (SVVel(k,1) - UserVel(1))*(SVPos(k,1)-UserPos(1)) + (SVVel(k,2) - UserVel(2))*(SVPos(k,2)-UserPos(2)) + (SVVel(k,3) - UserVel(3))*(SVPos(k,3)-UserPos(3));

            PR_Vec_minus_i(k,i) = geo_range_to_sat + UserPos(4) + xs_i(NumberStates+ProcessNoiseStates+k,i);% + UserVel(4) * gps_dt + xs_i(NumberStates+ProcessNoiseStates+k-1,i);  % geometric range + c * delta_T

            %predicted relative velocity of sv and receiver
            %Relative_Velocity(k) = geo_vel_to_sat/geo_range_to_sat;
            %PRR_Vec_minus_i(k,i) = Relative_Velocity(k) + UserVel(4) + xs_i(NumberStates+ProcessNoiseStates+NumberGPSMeasurements+k-1,i);
        end % for i=1:2*Na



    end  % for k = 1:NumberGPSMeasurements

    %ys_kminus_0 = [PR_Vec_minus_0'; PRR_Vec_minus_0'];
    %ys_kminus_i = [PR_Vec_minus_i(:,:); PRR_Vec_minus_i(:,:)];
    ys_kminus_0 = [PR_Vec_minus_0'];
    ys_kminus_i = [PR_Vec_minus_i(:,:)];

    % find the sum of sigma points for the measurement prediction
    W = ones(1,2*Na+1);
    W(1,1) = W_0_m;
    W(1,2:2*Na+1) = W_i_m;

    Y = zeros(MeasurementNoiseStates,2*Na+1);
    Y(:,1) = ys_kminus_0(1:MeasurementNoiseStates);
    Y(:,2:2*Na+1) = ys_kminus_i(1:MeasurementNoiseStates,:);
    y_hat_kminus = (W*Y')';
 
     nx = length(x_hat_kminus); ny = length(y_hat_kminus); nw = length(W);
     Py_kminus=((ones(ny,1)*W).*(Y-y_hat_kminus*ones(1,nw)))*(Y-y_hat_kminus*ones(1,nw))';
     Pxy_kminus =((ones(nx,1)*W).*(X-x_hat_kminus*ones(1,nw)))*(Y-y_hat_kminus*ones(1,nw))';

 

    %% Py_kminus is equivalent to HPxH'+R 
    %% Pxy_kminus PxH' 
    %% therefor Hequiv = (inv(Px_kminus)*Pxy_kminus)'
    % calculate 'H' by normalizing Pxy
    Hequiv = (inv(Px_kminus) * Pxy_kminus)';
    
    
    [lat,lon] = ECEF2LLH(ApproxPos);
    Tecef2ned2 = T_ECEF2NED(lon,lat);
    Tecef2ned2(4,1:3) = [0 0 0];
    Tecef2ned2(1:4,4) = [0 0 0 1];
    H_ltp = Hequiv * Tecef2ned2';
    
    
    
    % calculate covariance matrix (AA) and transform to local coords
    AA = inv(H_ltp' * H_ltp);
    
    % calculate DOPs
    var_x = AA(1,1);
    var_y = AA(2,2);
    var_z = AA(3,3);
    var_dt = AA(4,4);
    DOP_UKF(Epoch_lo,1) = sqrt(var_x + var_y + var_z + var_dt);
    DOP_UKF(Epoch_lo,2) = sqrt(var_x + var_y + var_z);
    DOP_UKF(Epoch_lo,3) = sqrt(var_x + var_y);
    DOP_UKF(Epoch_lo,4) = sqrt(var_z);
    DOP_UKF(Epoch_lo,5) = sqrt(var_dt);
    
    
    
    % calculate kalman gain
    K_k = Pxy_kminus * inv(Py_kminus);
    
    
    %K_k = (Pxy_kminus / Sy_kminus') / Sy_kminus;

    % apply correction
    z_k = y_k - y_hat_kminus;
    z_save(Epoch_lo,:) = z_k;
    

    
    x_hat_kplus = x_hat_kminus + K_k * (z_k);

    Px_kplus = Px_kminus - K_k * Py_kminus * K_k';


    %save results
    t_save(Epoch_lo) = Epoch_lo;
    x_hat_save(Epoch_lo,:) = x_hat_kplus;
    P_save(Epoch_lo,:) = diag(Px_kplus);


    % copy updated state to high-speed loop state for next round
    x_hat_kminus = x_hat_kplus;
    Px_kminus = Px_kplus;
    
    

    
    
    %% calculate solution using least squares for comparisson
    [LSQ_Solution(Epoch_lo,:), LSQ_Variance(Epoch_lo,:), LSQ_NumIterations(Epoch_lo), ...
        LSQ_ResidualVector(Epoch_lo,:), LSQ_M, LSQ_Fail(Epoch_lo), ...
        LSQ_limit(Epoch_lo), LSQ_DOP(Epoch_lo,:)] = GARD_LSQ([ApproxPos 0],NumberGPSMeasurements, PR_Vec_raw(1:NumberGPSMeasurements),SVPos(1:NumberGPSMeasurements,:));
    
    
    %% TODO: calculate EKF solution for comparisson
    
    
    
    
        
    %% convert results to LLH
    [x_save_llh(Epoch_lo,1),x_save_llh(Epoch_lo,2),x_save_llh(Epoch_lo,3)] = ECEF2LLH(x_hat_save(Epoch_lo,1:3));
    Tecef2ned = T_ECEF2NED(x_save_llh(Epoch_lo,2),x_save_llh(Epoch_lo,1));
    
    
    P_save_NED(Epoch_lo,1:3) = abs(Tecef2ned*P_save(Epoch_lo,1:3)');
    S_save_NED(Epoch_lo,1:3) = sqrt(P_save_NED(Epoch_lo,1:3));
    
    ECEFError_UKF(Epoch_lo,:) = x_hat_save(Epoch_lo,1:3) - meanECEF;
    ECEFError_LSQ(Epoch_lo,:) = LSQ_Solution(Epoch_lo,1:3) - meanECEF;
    
    %% calculate velocity in North-East-Down
    [lat,lon] = ECEF2LLH(meanECEF);
    Tecef2ned = T_ECEF2NED(lon,lat);
    
    NEDError_UKF(Epoch_lo,:) = Tecef2ned * ECEFError_UKF(Epoch_lo,:)';
    NEDError_LSQ(Epoch_lo,:) = Tecef2ned * ECEFError_LSQ(Epoch_lo,:)';
    
    %x_save_vel(Epoch_lo,:) = Tecef2ned*x_hat_save(Epoch_lo,4:6)';
    %P_save_vel(Epoch_lo,:) = abs(Tecef2ned*P_save(Epoch_lo,4:6)');
    
    %% calculate position error
%     pos_error_llh(Epoch_lo,:) = x_save_llh(Epoch_lo,:) - pos_truth_llh(2:4,Epoch_lo*100)';
%     pos_error_llh(Epoch_lo,1) = pos_error_llh(Epoch_lo,1) * RM;
%     pos_error_llh(Epoch_lo,2) = pos_error_llh(Epoch_lo,2) * RP * cos(pos_truth_llh(2,Epoch_lo*100));
    
    
%     vel_error_ned(Epoch_lo,:) = x_save_vel(Epoch_lo,:) - vel_truth(2:4,Epoch_lo*100)';

%% uncomment the below line if hte 11-state filter is used.
%    x_save_acc(Epoch_lo,:) = Tecef2ned*x_hat_save(Epoch_lo,9:11)';
    
    %% update R-matrix
%     if(Epoch_lo > 10)
%         for k = 1:NumberGPSMeasurements
%             R(k,k) = std(abs(z_save(:,k)))^2;
%             R(k+NumberGPSMeasurements,k+NumberGPSMeasurements) = std(abs(z_save(:,k+NumberGPSMeasurements)))^2;
%         end
%     end
%     
    
    
    
    
    disp(sprintf('Completed Epoch %d',Epoch_lo));

    
    
    
end



%% plot results
% figure();
% plot3(x_hat_save(:,1),x_hat_save(:,2),x_hat_save(:,3),'r+');
% 
% figure();
% plot(x_save_llh(:,2)*180/pi,x_save_llh(:,1)*180/pi,'r+');
% xlabel('Longitude (deg)');
% ylabel('Latitude (deg)');
% grid on;
% title('GPS UKF Position Solution');



% figure();
% subplot(3,1,1),plot(t_save,x_save_llh(:,1)*180/pi);
% title('Position Solution');
% ylabel('Latitude (deg)');
% subplot(3,1,2),plot(t_save,x_save_llh(:,2)*180/pi);
% ylabel('Longitude (deg)');
% subplot(3,1,3),plot(t_save,x_save_llh(:,3));
% ylabel('Height (m-WGS84)');
% xlabel('Time (sec)');
% 
% figure();
% subplot(3,1,1),plot(t_save,x_save_vel(:,1));
% title('Velocity Solution');
% ylabel('North (m/s)');
% subplot(3,1,2),plot(t_save,x_save_vel(:,2));
% ylabel('East (m/s)');
% subplot(3,1,3),plot(t_save,x_save_vel(:,3));
% ylabel('Down (m/s)');
% xlabel('Time (sec)');

% 
% subplot(3,1,1),plot(t_save,pos_error_llh(:,1));
% title('Position Error');
% hold on;
% subplot(3,1,1),plot(t_save,2*sqrt(P_save_llh(:,1)),'r');
% subplot(3,1,1),plot(t_save,-2*sqrt(P_save_llh(:,1)),'r');
% 
% subplot(3,1,2),plot(t_save,pos_error_llh(:,2));
% hold on;
% subplot(3,1,2),plot(t_save,2*sqrt(P_save_llh(:,2)),'r');
% subplot(3,1,2),plot(t_save,-2*sqrt(P_save_llh(:,2)),'r');
% 
% subplot(3,1,3),plot(t_save,pos_error_llh(:,3));
% hold on;
% subplot(3,1,3),plot(t_save,2*sqrt(P_save_llh(:,3)),'r');
% subplot(3,1,3),plot(t_save,-2*sqrt(P_save_llh(:,3)),'r');
% 
% 
% figure();
% subplot(3,1,1),plot(t_save,x_save_vel(:,1));
% title('Velocity');
% subplot(3,1,2),plot(t_save,x_save_vel(:,2));
% subplot(3,1,3),plot(t_save,x_save_vel(:,3));
% 
% figure();
% subplot(3,1,1),plot(t_save,vel_error_ned(:,1));
% title('Velocity Error');
% subplot(3,1,2),plot(t_save,vel_error_ned(:,2));
% subplot(3,1,3),plot(t_save,vel_error_ned(:,3));
% 
% figure();
% subplot(3,1,1),plot(t_save,x_save_acc(:,1));
% title('Acceleration');
% subplot(3,1,2),plot(t_save,x_save_acc(:,2));
% subplot(3,1,3),plot(t_save,x_save_acc(:,3));
% 
% 

% 
% figure();
% subplot(3,1,1),plot(t_save,LSQ_Solution(:,1));
% title('Least Square Snapshot Solution');
% ylabel('ECEF-X (m)');
% subplot(3,1,2),plot(t_save,LSQ_Solution(:,2));
% ylabel('ECEF-Y (m)');
% subplot(3,1,3),plot(t_save,LSQ_Solution(:,3));
% ylabel('ECEF-Z (m)');

figure();
subplot(3,1,1),plot(t_save,ECEFError_UKF(:,1),'b'); hold on;
subplot(3,1,1),plot(t_save,ECEFError_LSQ(:,1),'r');grid on;
ylabel('ECEF-X Error (m)');
title('Static Positioning UKF and LSQ Errors');
legend('UKF Error','LSQ Error');
subplot(3,1,2),plot(t_save,ECEFError_UKF(:,2),'b'); hold on;
subplot(3,1,2),plot(t_save,ECEFError_LSQ(:,2),'r');grid on;
ylabel('ECEF-Y Error (m)');

subplot(3,1,3),plot(t_save,ECEFError_UKF(:,3),'b'); hold on;
subplot(3,1,3),plot(t_save,ECEFError_LSQ(:,3),'r');grid on;
ylabel('ECEF-Z Error (m)');
xlabel('Test Time (sec)');

%% plot static positioning errors - UKF vs LSQ
figure();
subplot(3,1,1),plot(t_save/60,NEDError_UKF(:,1),'b'); hold on;
subplot(3,1,1),plot(t_save/60,NEDError_LSQ(:,1),'r');

grid on;
title('Static Positioning UKF and LSQ Errors');
legend('UKF Error','LSQ Error');
ylabel('North Error (m)');
subplot(3,1,2),plot(t_save/60,NEDError_UKF(:,2),'b'); hold on;
subplot(3,1,2),plot(t_save/60,NEDError_LSQ(:,2),'r'); 
grid on;
ylabel('East Error (m)');
subplot(3,1,3),plot(t_save/60,NEDError_UKF(:,3),'b'); hold on;
subplot(3,1,3),plot(t_save/60,NEDError_LSQ(:,3),'r');
grid on;
ylabel('Down Error (m)');
xlabel('Test Time (mins)');
% 
figure();
subplot(3,1,1),plot(t_save/60,NEDError_UKF(:,1),'b'); hold on;
subplot(3,1,1),plot(t_save/60,2*S_save_NED(:,1),'r');
subplot(3,1,1),plot(t_save/60,-2*S_save_NED(:,1),'r'); 

grid on;
title('UKF Error Bounds');
ylabel('North Error (m)');
subplot(3,1,2),plot(t_save/60,NEDError_UKF(:,2),'b'); hold on;
subplot(3,1,2),plot(t_save/60,2*S_save_NED(:,2),'r'); 
subplot(3,1,2),plot(t_save/60,-2*S_save_NED(:,2),'r'); 

grid on;
ylabel('East Error (m)');
subplot(3,1,3),plot(t_save/60,NEDError_UKF(:,3),'b'); hold on;
subplot(3,1,3),plot(t_save/60,2*S_save_NED(:,3),'r');
subplot(3,1,3),plot(t_save/60,-2*S_save_NED(:,3),'r');

grid on;
ylabel('Down Error (m)');
xlabel('Test Time (mins)');


% figure();
% plot(t_save,LSQ_DOP(:,1),'b');
% hold on;
% plot(t_save,LSQ_DOP(:,2),'r');
% plot(t_save,LSQ_DOP(:,3),'g');
% plot(t_save,LSQ_DOP(:,4),'k');
% plot(t_save,LSQ_DOP(:,5),'c');
% grid on;
% legend('GDOP','PDOP','HDOP', 'VDOP','TDOP');
% xlabel('Test Time (sec)');
% ylabel('DOP Value');
% title('Variation of DOP During Test Period');

%% plot DOPs
% figure();
% subplot(3,1,1),plot(t_save/60,DOP_UKF(:,3),'b'); hold on;
% subplot(3,1,1),plot(t_save/60,LSQ_DOP(:,3),'r'); grid on;
% ylabel('HDOP');
% title('DOP Values Calculated by UKF and Least-Squares');
% legend('UKF','LSQ');
% subplot(3,1,2),plot(t_save/60,DOP_UKF(:,4),'b'); hold on;
% subplot(3,1,2),plot(t_save/60,LSQ_DOP(:,4),'r'); grid on;
% ylabel('VDOP');
% 
% subplot(3,1,3),plot(t_save/60,DOP_UKF(:,5),'b'); hold on;
% subplot(3,1,3),plot(t_save/60,LSQ_DOP(:,5),'r'); grid on;
% ylabel('TDOP');
% xlabel('Test Time (minutes)');


%% plot residuals
figure();
subplot(2,1,1),plot(t_save/60,z_save);
ylabel('UKF Residuals');
legend(num2str((SV_Vec(1:NumberGPSMeasurements)')));
grid on;
subplot(2,1,2),plot(t_save/60,LSQ_ResidualVector);
ylabel('LSQ Residuals');
legend(num2str((SV_Vec(1:NumberGPSMeasurements)')));
grid on;


figure();
plot(t_save/60,z_save);
hold on;
plot(t_save/60,LSQ_ResidualVector);
legend(num2str((SV_Vec(1:NumberGPSMeasurements)')));
grid on;
xlabel('Test Time (min)');
ylabel('Residuals');

%% plot clock estimate
figure();
plot(t_save/60,x_hat_save(:,4))
hold on;
plot(t_save/60,LSQ_Solution(:,4),'r')
grid on;
xlabel('Test Time (mins)');
ylabel('Clock Estimates (m)');
title('Receiver Clock Bias');
legend('UKF','LSQ');


% 
% figure();
% plot(DeltaSVRange)
% legend(num2str(SV_Vec'))
